<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabric.js Chessboard with Drag and Drop</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        canvas {
            border: 1px solid #000;
        }
        #history {
            width: 400px;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #000;
            margin-top: 10px;
            padding: 10px;
            font-family: Arial, sans-serif;
            line-height: 1.4;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .move-number {
            display: inline-block;
            width: 30px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div id="white-timer">White: 00:00</div>
        <div id="black-timer">Black: 00:00</div>
    </div>
    <canvas id="canvas" width="400" height="400"></canvas>
    <div id="history"></div>
    <script>
        const canvas = new fabric.Canvas('canvas');
        const squareSize = 50;
        let turn = 'white';
        const history = [];
        let moveCount = 1;
        let whiteTime = 300;
        let blackTime = 300;
        let timerInterval;
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let dragStartPosition = null;
        let gameIsOver = false;

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (turn === 'white') {
                    whiteTime--;
                    updateTimerDisplay('white');
                } else {
                    blackTime--;
                    updateTimerDisplay('black');
                }
            }, 1000);
        }

        function updateTimerDisplay(color) {
            const timerElement = document.getElementById(`${color}-timer`);
            const time = color === 'white' ? whiteTime : blackTime;
            const minutes = String(Math.floor(time / 60)).padStart(2, '0');
            const seconds = String(time % 60).padStart(2, '0');
            timerElement.innerText = `${color.charAt(0).toUpperCase() + color.slice(1)}: ${minutes}:${seconds}`;
            if (time <= 0) {
                clearInterval(timerInterval);
                alert(`${color.charAt(0).toUpperCase() + color.slice(1)} time's up!`);
            }
        }

        function createChessboard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isLightSquare = (row + col) % 2 === 0;
                    const square = new fabric.Rect({
                        left: col * squareSize,
                        top: row * squareSize,
                        fill: isLightSquare ? '#eee' : '#8B4513',
                        width: squareSize,
                        height: squareSize,
                        selectable: false
                    });
                    canvas.add(square);
                }
            }
        }

        function isValidMove(fromRow, fromCol, toRow, toCol, piece) {
            if (fromRow === toRow && fromCol === toCol) return false;
            
            const pieceType = piece.pieceType.toLowerCase();
            const color = piece.pieceColor;

            const destPiece = getPieceAt(toRow, toCol);
            if (destPiece && destPiece.pieceColor === color) {
                return false;
            }

            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);

            switch (pieceType) {
                case 'p':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;
                    
                    if (colDiff === 0 && !destPiece) {
                        if (rowDiff === direction) return true;
                        if (fromRow === startRow && 
                            rowDiff === 2 * direction && 
                            !getPieceAt(fromRow + direction, fromCol)) {
                            return true;
                        }
                    }
                    
                    if (absColDiff === 1 && rowDiff === direction && destPiece) {
                        return true;
                    }
                    return false;

                case 'r':
                    if (fromRow !== toRow && fromCol !== toCol) return false;
                    return !isPathBlocked(fromRow, fromCol, toRow, toCol);

                case 'n':
                    return (absRowDiff === 2 && absColDiff === 1) || 
                           (absRowDiff === 1 && absColDiff === 2);

                case 'b':
                    if (absRowDiff !== absColDiff) return false;
                    return !isPathBlocked(fromRow, fromCol, toRow, toCol);

                case 'q':
                    if (fromRow === toRow || fromCol === toCol || absRowDiff === absColDiff) {
                        return !isPathBlocked(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'k':
                    return absRowDiff <= 1 && absColDiff <= 1;

                default:
                    return false;
            }
        }

        function isPathBlocked(fromRow, fromCol, toRow, toCol) {
            const rowDir = fromRow === toRow ? 0 : (toRow - fromRow) / Math.abs(toRow - fromRow);
            const colDir = fromCol === toCol ? 0 : (toCol - fromCol) / Math.abs(toCol - fromCol);
            
            let currentRow = fromRow + rowDir;
            let currentCol = fromCol + colDir;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (getPieceAt(currentRow, currentCol)) return true;
                currentRow += rowDir;
                currentCol += colDir;
            }
            
            return false;
        }

        function getPieceAt(row, col) {
            return boardState[row][col];
        }

        function addPieces() {
            
            const pieces = {
                'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
                'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
                'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
                'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
                'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
                'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
                'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
                'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
                'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
                'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
                'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
                'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg'
            };

            const initialBoardState = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['.', '.', '.', '.', '.', '.', '.', '.'],
                ['.', '.', '.', '.', '.', '.', '.', '.'],
                ['.', '.', '.', '.', '.', '.', '.', '.'],
                ['.', '.', '.', '.', '.', '.', '.', '.'],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = initialBoardState[row][col];
                    if (piece !== '.') {
                        fabric.loadSVGFromURL(pieces[piece], function(objects, options) {
                            const svgPiece = fabric.util.groupSVGElements(objects, options);
                            const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                            svgPiece.set({
                                left: col * squareSize + squareSize / 2,
                                top: row * squareSize + squareSize / 2,
                                originX: 'center',
                                originY: 'center',
                                hasControls: false,
                                hasBorders: false,
                                selectable: pieceColor === 'white', // Only white pieces selectable at start
                                pieceColor: pieceColor,
                                pieceType: piece.toLowerCase()
                            });
                            
                            boardState[row][col] = svgPiece;
                            canvas.add(svgPiece);

                                // Add mouse event listeners
                                svgPiece.on('mousedown', function() {
                                    this.setCoords();
                                    
                                    if (gameIsOver || this.pieceColor !== turn) {
                                        canvas.preventDefault(); // Prevent the drag operation from starting
                                        canvas.discardActiveObject();
                                        canvas.rendAll();
                                        return false;
                                    }
                                    dragStartPosition = {
                                        row: Math.floor(this.top / squareSize),
                                        col: Math.floor(this.left / squareSize),
                                        left: this.left,
                                        top: this.top
                                    };
                                });

                                this.selectable = true
    
                                svgPiece.on('moving', function() {
                                    if (!dragStartPosition || this.pieceColor !== turn) return;
                                    
                                    const currentRow = Math.floor(this.top / squareSize);
                                    const currentCol = Math.floor(this.left / squareSize);
                                    
                                    // Snap to grid while dragging
                                    this.set({
                                        left: currentCol * squareSize + squareSize / 2,
                                        top: currentRow * squareSize + squareSize / 2
                                    });
                                });
    
                                svgPiece.on('mouseup', function() {
                                     if (!dragStartPosition || this.pieceColor !== turn) {
                                        // Reset piece position if it's not their turn
                                        if (dragStartPosition) {
                                            this.set({
                                                left: dragStartPosition.left,
                                                top: dragStartPosition.top
                                            });
                                            canvas.renderAll();
                                        }
                                        dragStartPosition = null;
                                        return false;
                                    };
                                    
                                    const toRow = Math.floor(this.top / squareSize);
                                    const toCol = Math.floor(this.left / squareSize);
                                    const fromRow = dragStartPosition.row;
                                    const fromCol = dragStartPosition.col;
    
                                    if (isValidMove(fromRow, fromCol, toRow, toCol, this)) {
                                    // Valid move logic
                                    const destPiece = boardState[toRow][toCol];
                                    if (destPiece) {
                                        canvas.remove(destPiece);
                                    }
        
                                    boardState[toRow][toCol] = this;
                                    boardState[fromRow][fromCol] = null;
        
                                    const from = String.fromCharCode(fromCol + 'a'.charCodeAt(0)) + (8 - fromRow);
                                    const to = String.fromCharCode(toCol + 'a'.charCodeAt(0)) + (8 - toRow);
                                    updateHistory(this, from, to, destPiece);
        
                                    // Switch turns only after a valid move
                                    turn = turn === 'white' ? 'black' : 'white';
                                    if (turn === 'white') moveCount++;
                                        updateSelectableState(); // Update which pieces are selectable
                                        startTimer();
                                    } else {
                                        // Invalid move - revert position and allow retry
                                        this.set({
                                            left: dragStartPosition.left,
                                            top: dragStartPosition.top
                                    });
                                    obj.setCoords(); 

                                    alert("This is an invalid move. Try again")
                                }
                                
                                dragStartPosition = null;
                                canvas.renderAll();
                            });
                        });
                    }
                }
            }
        }

        function updateSelectableState() {
            canvas.forEachObject(function(obj) {
                if (obj.pieceColor) { // Check if it's a chess piece
                    obj.selectable = obj.pieceColor === turn;
                    obj.setCoords(); // Ensure all pieces update their coordinates
                }
            });
            canvas.renderAll();
        }


        function getPieceSymbol(piece) {
            const symbols = {
                'k': '♔', 'q': '♕', 'r': '♖', 'b': '♗', 'n': '♘', 'p': '♙',
                'K': '♚', 'Q': '♛', 'R': '♜', 'B': '♝', 'N': '♞', 'P': '♟'
            };
            const symbol = symbols[piece.pieceType.toUpperCase()];
            return piece.pieceColor === 'white' ? symbol : symbol.toLowerCase();
        }

        function updateHistory(piece, from, to, capturedPiece) {
            let moveText = '';
            const pieceNames = {
                'k': 'King',
                'q': 'Queen',
                'r': 'Rook',
                'b': 'Bishop',
                'n': 'Knight',
                'p': 'Pawn'
            };
            
            
            moveText += `<span class="move-number">${moveCount}.</span> `;
            
            const pieceName = pieceNames[piece.pieceType.toLowerCase()];
            const playerColor = piece.pieceColor.charAt(0).toUpperCase() + piece.pieceColor.slice(1);
            
            moveText += `${playerColor} ${pieceName} on ${from} `;
            
            if (!gameIsOver) {
                moveText += `moved to ${to}`;
            }

            if (capturedPiece) {
                const capturedPieceName = pieceNames[capturedPiece.pieceType.toLowerCase()];
                moveText += `captureing ${capturedPiece.pieceColor} ${capturedPieceName} `;
                
                // Check if a king was captured
                if (capturedPiece.pieceType.toLowerCase() === 'k') {
                    gameIsOver = true;
                    moveText += `- ${playerColor} wins the game!`;
                }
            }
            
            history.push(moveText);
            const historyDiv = document.getElementById('history');
            historyDiv.innerHTML = history.join('<br>');
            historyDiv.scrollTop = historyDiv.scrollHeight;
            
            if (gameIsOver) {
                clearInterval(timerInterval); // Stop the timer
                setTimeout(() => {
                    alert(`${playerColor} wins the game by capturing the ${capturedPiece.pieceColor} King!`);
                }, 100);
            }
        }

        createChessboard();
        addPieces();
        startTimer();
    </script>
</body>
</html>
