<!DOCTYPE html>
<html>
<head>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Make canvas fullscreen
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game states
const GAME_STATE = {
    MENU: 'menu',
    PLAYING: 'playing'
};
let currentState = GAME_STATE.MENU;

// Game configuration
const GRID_SIZE = 8;
const COLORS = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF'];
let cellSize;
let gridOffsetX;
let gridOffsetY;
const ANIMATION_SPEED = 0.2;

// Game variables
let grid = [];
let selectedPieces = [];
let connectionLine = [];

// Initialize grid
function initializeGrid() {
    grid = [];
    for (let i = 0; i < GRID_SIZE; i++) {
        grid[i] = [];
        for (let j = 0; j < GRID_SIZE; j++) {
            grid[i][j] = {
                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                x: i,
                y: j
            };
        }
    }
}

// Calculate grid dimensions
function calculateGridDimensions() {
    const minDimension = Math.min(canvas.width, canvas.height);
    cellSize = minDimension / (GRID_SIZE + 2);
    gridOffsetX = (canvas.width - cellSize * GRID_SIZE) / 2;
    gridOffsetY = (canvas.height - cellSize * GRID_SIZE) / 2;
}

// Draw menu
function drawMenu() {
    ctx.fillStyle = '#333333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '48px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Match Game', canvas.width / 2, canvas.height / 3);
    
    ctx.font = '24px Arial';
    ctx.fillText('Click to Start', canvas.width / 2, canvas.height / 2);
    ctx.fillText('Connect pieces in any direction, including diagonals!', canvas.width / 2, canvas.height / 2 + 40);
}

// Draw game board
function drawGame() {
    ctx.fillStyle = '#333333';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw connection line first (behind the pieces)
    if (connectionLine.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = cellSize / 4;
        
        const startX = gridOffsetX + connectionLine[0].x * cellSize + cellSize/2;
        const startY = gridOffsetY + connectionLine[0].y * cellSize + cellSize/2;
        ctx.moveTo(startX, startY);
        
        for (let i = 1; i < connectionLine.length; i++) {
            const x = gridOffsetX + connectionLine[i].x * cellSize + cellSize/2;
            const y = gridOffsetY + connectionLine[i].y * cellSize + cellSize/2;
            ctx.lineTo(x, y);
        }
        
        ctx.stroke();
    }
    
    // Draw grid
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            const x = gridOffsetX + i * cellSize;
            const y = gridOffsetY + j * cellSize;
            
            // Draw piece background (slight shadow effect)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw piece
            ctx.fillStyle = grid[i][j].color;
            ctx.beginPath();
            ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight selected pieces
            if (selectedPieces.some(piece => piece.x === i && piece.y === j)) {
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add a glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FFFFFF';
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
    }
}

// Handle mouse/touch input
function getGridPosition(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left - gridOffsetX) / cellSize);
    const y = Math.floor((clientY - rect.top - gridOffsetY) / cellSize);
    
    if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
        return { x, y };
    }
    return null;
}

function isAdjacent(piece1, piece2) {
    const dx = Math.abs(piece1.x - piece2.x);
    const dy = Math.abs(piece1.y - piece2.y);
    // Now allowing diagonal moves (dx and dy can both be 1)
    return dx <= 1 && dy <= 1;
}

function handleClick(clientX, clientY) {
    if (currentState === GAME_STATE.MENU) {
        currentState = GAME_STATE.PLAYING;
        initializeGrid();
        return;
    }
    
    const gridPos = getGridPosition(clientX, clientY);
    if (!gridPos) return;
    
    const clickedPiece = grid[gridPos.x][gridPos.y];
    
    // Check if the clicked position is already in the selection
    const alreadySelected = selectedPieces.some(piece => 
        piece.x === gridPos.x && piece.y === gridPos.y
    );
    
    if (selectedPieces.length === 0) {
        selectedPieces.push(gridPos);
        connectionLine.push(gridPos);
    } else if (!alreadySelected) {
        const lastPiece = selectedPieces[selectedPieces.length - 1];
        if (isAdjacent(lastPiece, gridPos) && 
            grid[lastPiece.x][lastPiece.y].color === clickedPiece.color) {
            selectedPieces.push(gridPos);
            connectionLine.push(gridPos);
        }
    }
}

function handleRelease() {
    if (selectedPieces.length >= 3) {
        // Remove matched pieces and drop new ones
        for (const piece of selectedPieces) {
            grid[piece.x][piece.y].color = COLORS[Math.floor(Math.random() * COLORS.length)];
        }
    }
    selectedPieces = [];
    connectionLine = [];
}

// Event listeners
canvas.addEventListener('mousedown', (e) => handleClick(e.clientX, e.clientY));
canvas.addEventListener('mousemove', (e) => {
    if (selectedPieces.length > 0) {
        handleClick(e.clientX, e.clientY);
    }
});
canvas.addEventListener('mouseup', handleRelease);
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    handleClick(touch.clientX, touch.clientY);
});
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (selectedPieces.length > 0) {
        const touch = e.touches[0];
        handleClick(touch.clientX, touch.clientY);
    }
});
canvas.addEventListener('touchend', handleRelease);

// Game loop
function gameLoop() {
    calculateGridDimensions();
    
    if (currentState === GAME_STATE.MENU) {
        drawMenu();
    } else {
        drawGame();
    }
    
    requestAnimationFrame(gameLoop);
}

// Start the game
gameLoop();
</script>
</body>
</html>
