import { useState, useEffect, useRef } from 'react';
import { Gem, Target, RefreshCw, Link, Play, Info, Settings, Home } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Switch } from '@/components/ui/switch';

const BOARD_SIZE = 6;
const COLORS = ['red', 'blue', 'green', 'purple', 'orange'];
const MIN_MATCH = 3;
const TILE_SIZE = 48;
const TILE_GAP = 4;

const getRandomColor = () => COLORS[Math.floor(Math.random() * COLORS.length)];

const StartMenu = ({ onStartGame, onShowInstructions, onShowSettings }) => (
  <Card className="w-[300px]">
    <CardHeader>
      <CardTitle className="text-center flex items-center justify-center gap-2">
        <Gem className="text-purple-500" size={32} />
        Color Chain
      </CardTitle>
    </CardHeader>
    <CardContent className="flex flex-col gap-4">
      <Button 
        onClick={onStartGame}
        className="w-full flex items-center justify-center gap-2"
      >
        <Play size={20} />
        Play Game
      </Button>
      <Button 
        variant="outline"
        onClick={onShowInstructions}
        className="w-full flex items-center justify-center gap-2"
      >
        <Info size={20} />
        How to Play
      </Button>
      <Button 
        variant="outline"
        onClick={onShowSettings}
        className="w-full flex items-center justify-center gap-2"
      >
        <Settings size={20} />
        Settings
      </Button>
    </CardContent>
  </Card>
);

const Instructions = ({ onBack }) => (
  <Card className="w-[300px]">
    <CardHeader>
      <CardTitle className="text-center">How to Play</CardTitle>
    </CardHeader>
    <CardContent className="flex flex-col gap-4">
      <div className="space-y-4 text-sm">
        <p>1. Click and drag to connect matching colors</p>
        <p>2. Connect at least 3 tiles to make a match</p>
        <p>3. You can move diagonally!</p>
        <p>4. Longer chains = more points</p>
        <p>5. Clear tiles before running out of moves</p>
      </div>
      <Button 
        onClick={onBack}
        className="w-full flex items-center justify-center gap-2"
      >
        <Home size={20} />
        Back to Menu
      </Button>
    </CardContent>
  </Card>
);

const Settings = ({ settings, onUpdateSettings, onBack }) => (
  <Card className="w-[300px]">
    <CardHeader>
      <CardTitle className="text-center">Settings</CardTitle>
    </CardHeader>
    <CardContent className="flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <label htmlFor="sfx">Sound Effects</label>
        <Switch 
          id="sfx"
          checked={settings.sfx}
          onCheckedChange={(checked) => onUpdateSettings({ ...settings, sfx: checked })}
        />
      </div>
      <div className="flex items-center justify-between">
        <label htmlFor="music">Background Music</label>
        <Switch 
          id="music"
          checked={settings.music}
          onCheckedChange={(checked) => onUpdateSettings({ ...settings, music: checked })}
        />
      </div>
      <Button 
        onClick={onBack}
        className="w-full flex items-center justify-center gap-2"
      >
        <Home size={20} />
        Back to Menu
      </Button>
    </CardContent>
  </Card>
);

const Game = ({ onBack, settings }) => {
  // ... (Previous game state and helper functions remain the same)
  const [board, setBoard] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [selectedTiles, setSelectedTiles] = useState(new Set());
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(15);
  const [gameOver, setGameOver] = useState(false);
  const lastTile = useRef(null);
  const boardRef = useRef(null);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  // ... (All the previous game logic functions remain the same)
  const initializeBoard = () => {
    const newBoard = Array(BOARD_SIZE).fill().map(() => 
      Array(BOARD_SIZE).fill().map(() => getRandomColor())
    );
    setBoard(newBoard);
    setScore(0);
    setMoves(15);
    setGameOver(false);
  };

  useEffect(() => {
    initializeBoard();
  }, []);

  // ... (Copy all the previous game logic here - handleTileMouseDown, handleTileMouseEnter, etc.)
  // For brevity, I'm not repeating all the game logic, but it should remain exactly the same

  return (
    <div className="flex flex-col items-center gap-4 p-4">
      <div className="flex gap-4 mb-4">
        <Button 
          variant="outline" 
          size="sm"
          onClick={onBack}
          className="flex items-center gap-2"
        >
          <Home size={16} />
          Menu
        </Button>
        <div className="flex items-center gap-2">
          <Gem className="text-purple-500" />
          <span className="font-bold">Score: {score}</span>
        </div>
        <div className="flex items-center gap-2">
          <Target className="text-red-500" />
          <span className="font-bold">Moves: {moves}</span>
        </div>
      </div>

      <div 
        ref={boardRef}
        className="grid gap-1 p-2 bg-gray-100 rounded-lg relative"
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onMouseMove={handleMouseMove}
      >
        {/* ... Rest of the game board rendering ... */}
        {renderConnectionLines()}
        {board.map((row, rowIndex) => (
          <div key={rowIndex} className="flex gap-1">
            {row.map((color, colIndex) => (
              <button
                key={`${rowIndex}-${colIndex}`}
                className={`w-12 h-12 rounded-lg transition-all duration-200 ${
                  selectedTiles.has(`${rowIndex}-${colIndex}`)
                    ? 'ring-4 ring-yellow-400 scale-110'
                    : ''
                } hover:brightness-110`}
                style={{ backgroundColor: color }}
                onMouseDown={(e) => handleTileMouseDown(rowIndex, colIndex, e)}
                onMouseEnter={() => handleTileMouseEnter(rowIndex, colIndex)}
                disabled={gameOver}
              />
            ))}
          </div>
        ))}
      </div>

      {gameOver && (
        <Alert className="w-full max-w-md">
          <AlertDescription>
            Game Over! Final Score: {score}
            <Button 
              onClick={initializeBoard}
              className="w-full mt-4 flex items-center justify-center gap-2"
            >
              <RefreshCw className="w-4 h-4" />
              Play Again
            </Button>
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
};

const Match3Game = () => {
  const [currentScreen, setCurrentScreen] = useState('menu');
  const [settings, setSettings] = useState({
    sfx: true,
    music: true
  });

  const renderScreen = () => {
    switch (currentScreen) {
      case 'menu':
        return (
          <StartMenu 
            onStartGame={() => setCurrentScreen('game')}
            onShowInstructions={() => setCurrentScreen('instructions')}
            onShowSettings={() => setCurrentScreen('settings')}
          />
        );
      case 'instructions':
        return (
          <Instructions 
            onBack={() => setCurrentScreen('menu')}
          />
        );
      case 'settings':
        return (
          <Settings 
            settings={settings}
            onUpdateSettings={setSettings}
            onBack={() => setCurrentScreen('menu')}
          />
        );
      case 'game':
        return (
          <Game 
            settings={settings}
            onBack={() => setCurrentScreen('menu')}
          />
        );
      default:
        return null;
    }
  };

  return (
    <div className="flex items-center justify-center min-h-[600px]">
      {renderScreen()}
    </div>
  );
};

export default Match3Game;
