<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Babylon.js Village</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTFSerializer.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas" style="width: 100%; height: 100%;"></canvas>
    <button id="downloadButton" style="position: absolute; top: 20px; left: 20px; z-index: 10;">Download Scene GLB</button>
    
    <script>
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);

            // Skybox and base scene setup
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.emissiveColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            skybox.material = skyboxMaterial;

            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 1.5, Math.PI / 2.2, 15, new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas, true);
            
            // Lighting system
            const sunLight = new BABYLON.DirectionalLight("sunLight", new BABYLON.Vector3(0, -1, 0), scene);
            sunLight.intensity = 1;
            const hemisphericLight = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            // GUI Setup
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "200px";
            panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            advancedTexture.addControl(panel);

            // Weather System
            const rainSystem = new BABYLON.ParticleSystem("rain", 5000, scene);
            rainSystem.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACdJREFUeNpiYGBg+A/EQGxmogwG/Q+XYGKAASYGHICRUQUDAwAAAgwAK1ECzVrCqQUAAAAASUVORK5CYII=");
            rainSystem.emitter = new BABYLON.Vector3(0, 20, 0);
            rainSystem.minEmitBox = new BABYLON.Vector3(-20, 0, -20);
            rainSystem.maxEmitBox = new BABYLON.Vector3(20, 0, 20);
            rainSystem.color1 = new BABYLON.Color4(0.9, 0.9, 1.0, 0.1);
            rainSystem.color2 = new BABYLON.Color4(0.9, 0.9, 1.0, 0.1);
            rainSystem.colorDead = new BABYLON.Color4(0.9, 0.9, 1.0, 0.0);
            rainSystem.minSize = 0.1;
            rainSystem.maxSize = 0.3;
            rainSystem.minLifeTime = 0.5;
            rainSystem.maxLifeTime = 1.0;
            rainSystem.emitRate = 2000;
            rainSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
            rainSystem.direction1 = new BABYLON.Vector3(0, -1, 0);
            rainSystem.direction2 = new BABYLON.Vector3(0, -1, 0);
            rainSystem.minAngularSpeed = 0;
            rainSystem.maxAngularSpeed = Math.PI;
            rainSystem.minEmitPower = 1;
            rainSystem.maxEmitPower = 3;
            rainSystem.updateSpeed = 0.01;

            // Weather toggle button
            const weatherButton = BABYLON.GUI.Button.CreateSimpleButton("weatherBtn", "Toggle Rain");
            weatherButton.width = "150px";
            weatherButton.height = "40px";
            weatherButton.color = "white";
            weatherButton.background = "green";
            weatherButton.onPointerUpObservable.add(() => {
                if (rainSystem.isStarted()) {
                    rainSystem.stop();
                } else {
                    rainSystem.start();
                }
            });
            panel.addControl(weatherButton);

            // Time of day system
            let timeOfDay = 0;
            scene.onBeforeRenderObservable.add(() => {
                timeOfDay += 0.001;
                if (timeOfDay > Math.PI * 2) timeOfDay = 0;
                
                sunLight.direction = new BABYLON.Vector3(
                    Math.sin(timeOfDay),
                    -Math.cos(timeOfDay),
                    0
                );
                
                const intensity = Math.max(0.2, Math.sin(timeOfDay) + 0.5);
                sunLight.intensity = intensity;
                skyboxMaterial.emissiveColor.set(intensity * 0.15, intensity * 0.15, intensity * 0.2);
            });

            // Load village model
            BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "village.glb");

            // Character movement track
            const walk = function (turn, dist) {
                this.turn = turn;
                this.dist = dist;
            }
            
            const track = [];
            track.push(new walk(86, 7));
            track.push(new walk(-85, 14.8));
            track.push(new walk(-93, 16.5));
            track.push(new walk(48, 25.5));
            track.push(new walk(-112, 30.5));
            track.push(new walk(-72, 33.2));
            track.push(new walk(42, 37.5));
            track.push(new walk(-98, 45.2));
            track.push(new walk(0, 47));

            // Load and animate character
            BABYLON.SceneLoader.ImportMeshAsync("him", "./", "Dude3.babylon", scene).then((result) => {
                var dude = result.meshes[0];
                dude.scaling = new BABYLON.Vector3(0.012, 0.012, 0.012);
                dude.position = new BABYLON.Vector3(-6, 0, 0);
                dude.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(-95), BABYLON.Space.LOCAL);
                const startRotation = dude.rotationQuaternion.clone();    

                // Shadow setup for character
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, sunLight);
                shadowGenerator.addShadowCaster(dude);
                shadowGenerator.useExponentialShadowMap = true;

                scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);

                let distance = 0;
                let step = 0.015;
                let p = 0;

                scene.onBeforeRenderObservable.add(() => {
                    dude.movePOV(0, 0, step);
                    distance += step;
                    
                    if (distance > track[p].dist) {
                        dude.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(track[p].turn), BABYLON.Space.LOCAL);
                        p += 1;
                        p %= track.length;
                        if (p === 0) {
                            distance = 0;
                            dude.position = new BABYLON.Vector3(-6, 0, 0);
                            dude.rotationQuaternion = startRotation.clone();
                        }
                    }
                });
            });

            // Physics setup
            scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0));
            
            // Create physics ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(
                ground, 
                BABYLON.PhysicsImpostor.BoxImpostor, 
                {mass: 0, restitution: 0.9}, 
                scene
            );
            ground.visibility = 0;

            // Create Stanford Bunny
            BABYLON.SceneLoader.ImportMesh(
                "",
                "./",
                "StanfordBunny.obj",
                scene,
                function (meshes) {
                    meshes.forEach(mesh => {
                        mesh.position = new BABYLON.Vector3(0, 0, 0);
                        mesh.scaling = new BABYLON.Vector3(2, 2, 2);
                    });
                }
            );

            // Interactive spheres with physics
            const spherePositions = [
                new BABYLON.Vector3(0, 5, 0),
                new BABYLON.Vector3(2, 5, 0),
                new BABYLON.Vector3(-2, 5, 0)
            ];

            spherePositions.forEach((position, index) => {
                const sphere = BABYLON.MeshBuilder.CreateSphere("sphere" + index, {
                    diameter: 1,
                    segments: 32
                }, scene);
                
                sphere.position = position;
                
                const material = new BABYLON.StandardMaterial("sphereMaterial" + index, scene);
                material.diffuseColor = new BABYLON.Color3(
                    Math.random(),
                    Math.random(),
                    Math.random()
                );
                sphere.material = material;
                
                sphere.physicsImpostor = new BABYLON.PhysicsImpostor(
                    sphere, 
                    BABYLON.PhysicsImpostor.SphereImpostor, 
                    {mass: 1, restitution: 0.9}, 
                    scene
                );
                
                sphere.actionManager = new BABYLON.ActionManager(scene);
                sphere.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPickTrigger,
                        function(evt) {
                            const randomImpulse = new BABYLON.Vector3(
                                (Math.random() - 0.5) * 10,
                                5,
                                (Math.random() - 0.5) * 10
                            );
                            evt.source.physicsImpostor.applyImpulse(
                                randomImpulse,
                                evt.source.getAbsolutePosition()
                            );
                        }
                    )
                );
            });

            return scene;
        };

        var scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

        function exportToGLB() {
            BABYLON.GLTF2Export.GLBAsync(scene, "enhanced_scene.glb").then((glb) => {
                glb.downloadFiles();
            });
        }

        document.getElementById("downloadButton").addEventListener("click", exportToGLB);
    </script>
</body>
</html>
