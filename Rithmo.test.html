<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Rithmomachia</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .game-board {
            border: 2px solid #333;
            margin-bottom: 20px;
        }
        #history {
            border: 1px solid #333;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rithmomachia</h1>
        <div class="game-board">
            <canvas id="gameCanvas" width="800" height="400"></canvas>
        </div>
        <div id="history"></div>
    </div>

    <script>
        const canvas = new fabric.Canvas('gameCanvas', {
            selection: false
        });
        
        const squareSize = 50;
        let turn = 'white';
        const history = [];
        let moveCount = 1;
        let selectedPiece = null;
        let startPos = null;

        // Create board squares
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 16; col++) {
                const square = new fabric.Rect({
                    left: col * squareSize,
                    top: row * squareSize,
                    width: squareSize,
                    height: squareSize,
                    fill: (row + col) % 2 === 0 ? '#eee' : '#8B4513',
                    selectable: false,
                    hoverCursor: 'default'
                });
                canvas.add(square);
            }
        }

        // Define piece types and their starting positions
        const initialBoard = [
            ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
            ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
            ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
            ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
            ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
            ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
            ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
            ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's']
        ];

        // Load and place pieces
        function addPiece(piece, row, col) {
            const isWhite = piece === piece.toUpperCase();
            const pieceType = piece.toLowerCase();
            let imgUrl;
            
            switch (pieceType) {
                case 's': imgUrl = isWhite ? 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg' 
                                         : 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg'; break;
                case 't': imgUrl = isWhite ? 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg'
                                         : 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg'; break;
                case 'c': imgUrl = isWhite ? 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg'
                                         : 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg'; break;
            }

            fabric.loadSVGFromURL(imgUrl, function(objects, options) {
                const pieceObj = fabric.util.groupSVGElements(objects, options);
                pieceObj.set({
                    left: col * squareSize,
                    top: row * squareSize,
                    width: squareSize,
                    height: squareSize,
                    originX: 'left',
                    originY: 'top',
                    hasControls: false,
                    hasBorders: false,
                    lockRotation: true,
                    pieceType: pieceType,
                    isWhite: isWhite
                });

                // Add piece movement handlers
                pieceObj.on('mousedown', function(e) {
                    if ((isWhite && turn === 'white') || (!isWhite && turn === 'black')) {
                        selectedPiece = this;
                        startPos = { x: this.left, y: this.top };
                    }
                });

                pieceObj.on('moving', function(e) {
                    if (selectedPiece === this) {
                        // Snap to grid
                        const gridX = Math.round(this.left / squareSize) * squareSize;
                        const gridY = Math.round(this.top / squareSize) * squareSize;
                        this.set({
                            left: gridX,
                            top: gridY
                        });
                    }
                });

                pieceObj.on('mouseup', function(e) {
                    if (selectedPiece === this) {
                        const newCol = Math.round(this.left / squareSize);
                        const newRow = Math.round(this.top / squareSize);
                        const oldCol = Math.round(startPos.x / squareSize);
                        const oldRow = Math.round(startPos.y / squareSize);

                        // Check if move is valid
                        if (newCol >= 0 && newCol < 16 && newRow >= 0 && newRow < 8) {
                            // Update history
                            const from = String.fromCharCode(97 + oldCol) + (8 - oldRow);
                            const to = String.fromCharCode(97 + newCol) + (8 - newRow);
                            const moveText = `${moveCount}. ${turn} ${pieceType} ${from}-${to}`;
                            
                            const historyDiv = document.getElementById('history');
                            historyDiv.innerHTML += moveText + '<br>';
                            historyDiv.scrollTop = historyDiv.scrollHeight;
                            
                            moveCount++;
                            turn = turn === 'white' ? 'black' : 'white';
                        } else {
                            // Invalid move - return to start position
                            this.set({
                                left: startPos.x,
                                top: startPos.y
                            });
                        }
                        canvas.renderAll();
                        selectedPiece = null;
                        startPos = null;
                    }
                });

                canvas.add(pieceObj);
            });
        }

        // Place all pieces
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 16; col++) {
                if (initialBoard[row][col] !== '.') {
                    addPiece(initialBoard[row][col], row, col);
                }
            }
        }

        canvas.renderAll();
    </script>
</body>
</html>
