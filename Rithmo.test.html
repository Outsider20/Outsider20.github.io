<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rithmomachia</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap');

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    .title {
      font-family: 'Playfair Display', serif;
      font-size: 48px;
      font-weight: 700;
      text-align: center;
      color: #333;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      width: 100%;
      max-width: 800px;
    }

    .game-board {
      position: relative;
      width: 800px;
      height: 400px;
      border: 2px solid #333;
      border-radius: 8px;
      background-color: #f5f5f5;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .game-board::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: radial-gradient(circle, #333 1px, transparent 1px);
      background-size: 80px 40px;
      opacity: 0.1;
      z-index: 0;
    }

    .scale-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .scale-controls input {
      width: 200px;
    }

    .scale-controls label {
      font-family: 'Playfair Display', serif;
      font-weight: 700;
      color: #333;
    }
  .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
  #history {
            flex-grow: 1;
            width: 200px;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
            line-height: 1.4;
  }
    
  </style>
</head>
<body>
  <div class="container">
    <div class="title">Rithmomachia</div>
    <div class="game-container">
      <div class="game-board">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
      </div>
      <div class="scale-controls">
        <label for="scale">Adjust Size:</label>
        <input type="range" id="scale" min="50" max="150" value="100" step="10">
      </div>
      <div class="history-container">
        <h2>Move History</h2>
        <div id="history"></div>
      </div>
    </div>
  </div>

  <script>
        const canvas = new fabric.Canvas('gameCanvas');
        const squareSize = 50;
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let turn = null;
        let moveCount = 1;
        let history = [];
        let dragStartPosition = null;


      function addPieces() {
            
            const pieces = {
                's': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
                't': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
                'c': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
                'S': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
                'T': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
                'C': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
            };

                const initialBoardState = [
                ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
                ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
                ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
                ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
                ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
                ['.', 'T', 'C', 'C', '.', '.', '.', '.', '.', '.', '.', '.', 'c', 'c', 't', '.'],
                ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's'],
                ['S', 'S', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 't', 's', 's']
              ];

             for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 16; col++) {
                        const piece = initialBoardState[row][col];
                    
                        if (piece !== '.') {
                                fabric.loadSVGFromURL(pieces[piece], function(objects, options) {
                                const svgPiece = fabric.util.groupSVGElements(objects, options);
                                const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                                    svgPiece.set({
                                        left: col * squareSize + squareSize / 2,
                                        top: row * squareSize + squareSize / 2,
                                        originX: 'center',
                                        originY: 'center',
                                        hasControls: false,
                                        hasBorders: false,
                                        selectable: true,
                                        pieceColor: pieceColor,
                                        pieceType: piece.toLowerCase()
                                    });
                                        
                                    boardState[row][col] = svgPiece;
                                    canvas.add(svgPiece);

                                    svgPiece.on('mousedown', function(event) {
                                        // Reset the piece's state
                                        this.setCoords();
                                        
                                        // If it's not this piece's turn or the game is over, prevent selection
                                        if (this.pieceColor !== turn) {
                                            canvas.discardActiveObject();
                                            canvas.renderAll();
                                            return false;
                                        }
                                            
                                        const currentRow = Math.floor(this.top / squareSize);
                                        const currentCol = Math.floor(this.left / squareSize);
                                          
                                        // If there's an existing dragStartPosition
                                        if (dragStartPosition) {
                                            // If clicking the same piece, deselect it
                                            if (dragStartPosition.row === currentRow && dragStartPosition.col === currentCol) {
                                                this.set({
                                                    left: dragStartPosition.left,
                                                    top: dragStartPosition.top
                                                });
                                                dragStartPosition = null;
                                                canvas.discardActiveObject();
                                                canvas.renderAll();
                                                return false;
                                            } else {
                                                // If clicking a different piece, update dragStartPosition
                                                dragStartPosition = {
                                                    row: currentRow,
                                                    col: currentCol,
                                                    left: this.left,
                                                    top: this.top
                                                };
                                            }
                                            } else {
                                                // If no piece was previously selected, set dragStartPosition
                                                dragStartPosition = {
                                                    row: currentRow,
                                                    col: currentCol,
                                                    left: this.left,
                                                    top: this.top
                                                };
                                            }
                                            
                                        // Make sure the piece is selectable and movable
                                        this.selectable = true;
                                    });
                                }
                          }
                    }


                            this.selectable = true
    
                            svgPiece.on('moving', function() {
                                if (!dragStartPosition || this.pieceColor !== turn) return;
                                    
                                const currentRow = Math.floor(this.top / squareSize);
                                const currentCol = Math.floor(this.left / squareSize);
                                    
                                // Snap to grid while dragging
                                this.set({
                                    left: currentCol * squareSize + squareSize / 2,
                                    top: currentRow * squareSize + squareSize / 2
                                });
                            });
    
                            svgPiece.on('mouseup', function() {
                              if (!dragStartPosition || this.pieceColor !== turn) {
                                  // Reset piece position if it's not their turn
                                  if (dragStartPosition) {
                                      this.set({
                                          left: dragStartPosition.left,
                                          top: dragStartPosition.top
                                      });
                                      canvas.renderAll();
                                  }
                                  dragStartPosition = null;
                                  return false;
                              }
                              
                              const toRow = Math.floor(this.top / squareSize);
                              const toCol = Math.floor(this.left / squareSize);
                              const fromRow = dragStartPosition.row;
                              const fromCol = dragStartPosition.col;
                          
                              // If the piece was dropped in the same position it started from, keep it selected
                              if (toRow === fromRow && toCol === fromCol) {
                                  return;
                              }
                          
                              const destPiece = boardState[toRow][toCol];
                              if (destPiece) {
                                  canvas.remove(destPiece);
                              }
                              
                              boardState[toRow][toCol] = this;
                              boardState[fromRow][fromCol] = null;
                          
                              const from = String.fromCharCode(fromCol + 'a'.charCodeAt(0)) + (8 - fromRow);
                              const to = String.fromCharCode(toCol + 'a'.charCodeAt(0)) + (8 - toRow);
                              updateHistory(this, from, to, destPiece);
                          
                              turn = turn === 'white' ? 'black' : 'white';
                              moveCount++;
                              
                              dragStartPosition = null;
                              canvas.renderAll();
                          });
                    });
                }
            }
        }

        function createChessboard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 16; col++) {
                    const isLightSquare = (row + col) % 2 === 0;
                    const square = new fabric.Rect({
                        left: col * squareSize,
                        top: row * squareSize,
                        fill: isLightSquare ? '#eee' : '#8B4513',
                        width: squareSize,
                        height: squareSize,
                        selectable: false
                    });
                    canvas.add(square);
                }
            }
        };

        
        function updateHistory(piece, from, to, destPiece) {
            let moveTextHtml = '';
            
            const pieceNames = {
                'c': 'Circle', 't': 'Triangle', 's': 'Square',
            };
            
            moveTextHtml += `<span class="move-number">${moveCount}.</span> `;
            
            const pieceName = pieceNames[piece.pieceType.toLowerCase()];
            const playerColor = piece.pieceColor.charAt(0).toUpperCase() + piece.pieceColor.slice(1);
            
            const moveDescription = `${playerColor} ${pieceName} from ${from} to ${to}`;
            moveTextHtml += moveDescription;
            
            if (destPiece) {
                const capturedPieceName = pieceNames[destPiece.pieceType.toLowerCase()];
                const captureText = ` capturing ${destPiece.pieceColor} ${capturedPieceName}`;
                moveTextHtml += captureText;
            }
        
            // Add move to history
            history.push(moveTextHtml);
            
            // Update history display
            const historyDiv = document.getElementById('history');
            historyDiv.innerHTML = history.join('<br>');
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }

    createChessboard();
    addPieces();
  </script>
</body>
</html>
