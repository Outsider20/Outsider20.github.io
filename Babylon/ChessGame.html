<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTF2Serializer.min.js"></script>
    <style>
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .board-container {
            flex-shrink: 0;
        }
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .scale-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .scale-controls input {
            width: 200px;
        }
        .scale-controls label {
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #renderCanvas {
            border: 1px solid #000;
            width: 600px;
            height: 600px;
            touch-action: none;
        }
        .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #history {
            flex-grow: 1;
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="game-controls">
                <button id="startButton">Start Game</button>
                <button id="restartButton" disabled>Restart Game</button>
                <button id="exportButton">Export GLB</button>
            </div>
            
            <div class="scale-controls">
                <label for="pieceScale">Piece Scale:</label>
                <input type="range" id="pieceScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="scaleValue">1.0</span>
            </div>
            
            <div id="hud">
                <div id="white-timer">White: 05:00</div>
                <div id="black-timer">Black: 05:00</div>
            </div>
            
            <canvas id="renderCanvas"></canvas>
        </div>
        <div class="history-container">
            <h2>Move History</h2>
            <div id="history"></div>
        </div>
    </div>

        <script>
        // Global variables
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let gameStarted = false;
        let gameIsOver = false;
        let selectedPiece = null;
        let turn = 'white';
        let moveCount = 0;
        let history = [];
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let whiteTimer = 300; // 5 minutes in seconds
        let blackTimer = 300;
        let timerInterval;
        let scene;
        let highlightedSquares = [];
        let selectedPieceMesh = null;
        let validMoveIndicators = [];
        const HIGHLIGHT_COLOR = new BABYLON.Color3(0.4, 0.7, 0.4);
        let isDragging = false;
        let dragStartPosition = null;

        // Create the 3D scene
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                12,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 20;
            
            // Lighting
            const light = new BABYLON.HemisphericLight(
                "light",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            
            // Create chessboard
            createChessboard(scene);
            
            // Create and position pieces
            await setupPieces(scene);
            
            // Setup interaction
            setupInteraction(scene);
            
            return scene;
        }

        function createChessboard(scene) {
            const boardMaterial = new BABYLON.StandardMaterial("boardMat", scene);
            boardMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            
            // Create board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = BABYLON.MeshBuilder.CreateBox(
                        `square_${row}_${col}`,
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    
                    square.position = new BABYLON.Vector3(
                        row - 4 + 0.5,
                        -0.05,
                        col - 4 + 0.5
                    );
                    
                    const material = new BABYLON.StandardMaterial(
                        `squareMat_${row}_${col}`,
                        scene
                    );
                    material.diffuseColor = (row + col) % 2 === 0
                        ? new BABYLON.Color3(1, 1, 1)
                        : new BABYLON.Color3(0.4, 0.4, 0.4);
                    
                    square.material = material;
                    square.boardPosition = { row, col };
                }
            }
        }

        async function loadPieceModel(scene, type) {
            const modelMap = {
                'pawn': 'pawn.glb',
                'rook': 'rook.glb',
                'knight': 'knight.glb',
                'bishop': 'bishop.glb',
                'queen': 'queen.glb',
                'king': 'chess_king.glb'
            };

            const fileName = modelMap[type.toLowerCase()];
            if (!fileName) {
                throw new Error(`Unknown piece type: ${type}`);
            }

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    "",
                    "./",
                    fileName,
                    scene
                );

                const rootMesh = result.meshes[0];
                const container = new BABYLON.Mesh("container", scene);
                
                result.meshes.forEach(mesh => {
                    if (mesh !== rootMesh) {
                        mesh.parent = container;
                    }
                });

                container.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);

                const boundingBox = container.getHierarchyBoundingVectors(true);
                const dimensions = boundingBox.max.subtract(boundingBox.min);
                const centerOffset = dimensions.scale(0.5);
                container.position.y = -boundingBox.min.y;

                return container;
            } catch (error) {
                console.error(`Error loading model ${fileName}:`, error);
                throw error;
            }
        }

        async function createPiece(scene, type, row, col, color) {
            const piece = await loadPieceModel(scene, type);
            
            piece.position = new BABYLON.Vector3(
                row - 4 + 0.5,
                0,
                col - 4 + 0.5
            );
            
            const material = new BABYLON.StandardMaterial(`${color}${type}Mat`, scene);
            material.diffuseColor = color === 'white'
                ? new BABYLON.Color3(0.9, 0.9, 0.9)
                : new BABYLON.Color3(0.2, 0.2, 0.2);
            
            piece.getChildMeshes().forEach(mesh => {
                mesh.material = material;
            });
            
            piece.pieceInfo = { type, color };
            boardState[row][col] = piece;
            
            return piece;
        }

        async function setupPieces(scene) {
            const pieces = [
                { type: 'rook', positions: [[0, 0], [0, 7], [7, 0], [7, 7]] },
                { type: 'knight', positions: [[0, 1], [0, 6], [7, 1], [7, 6]] },
                { type: 'bishop', positions: [[0, 2], [0, 5], [7, 2], [7, 5]] },
                { type: 'queen', positions: [[0, 3], [7, 3]] },
                { type: 'king', positions: [[0, 4], [7, 4]] }
            ];
            
            // Create pawns
            for (let col = 0; col < 8; col++) {
                await createPiece(scene, 'pawn', 1, col, 'black');
                await createPiece(scene, 'pawn', 6, col, 'white');
            }
            
            // Create other pieces
            for (const piece of pieces) {
                for (const [row, col] of piece.positions) {
                    const color = row === 0 ? 'black' : 'white';
                    await createPiece(scene, piece.type, row, col, color);
                }
            }
        }
            
        function getBoardPosition(position) {
            const row = Math.floor(position.x + 4);
            const col = Math.floor(position.z + 4);
            return { row, col };
        }

       function isValidMove(piece, targetPos) {
            if (!piece || !piece.pieceInfo) return false;
            
            const currentPos = getBoardPosition(piece.position);
            const type = piece.pieceInfo.type.toLowerCase();
            const color = piece.pieceInfo.color;
            
            // Check if moving to same position
            if (currentPos.row === targetPos.row && currentPos.col === targetPos.col) {
                return false;
            }
            
            // Check if target square has a piece of same color
            const targetPiece = boardState[targetPos.row][targetPos.col];
            if (targetPiece && targetPiece.pieceInfo.color === color) {
                return false;
            }
            
            // Basic validation for each piece type
            switch (type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;
                    
                    // Regular move forward
                    if (currentPos.col === targetPos.col && !targetPiece) {
                        if (targetPos.row === currentPos.row + direction) {
                            return true;
                        }
                        // First move can be two squares
                        if (currentPos.row === startRow && 
                            targetPos.row === currentPos.row + (2 * direction) &&
                            !boardState[currentPos.row + direction][currentPos.col]) {
                            return true;
                        }
                    }
                    
                    // Capture move
                    if (targetPos.row === currentPos.row + direction &&
                        Math.abs(targetPos.col - currentPos.col) === 1 &&
                        targetPiece) {
                        return true;
                    }
                    return false;
                    
                case 'rook':
                    return (currentPos.row === targetPos.row || currentPos.col === targetPos.col);
                    
                case 'knight':
                    const rowDiff = Math.abs(targetPos.row - currentPos.row);
                    const colDiff = Math.abs(targetPos.col - currentPos.col);
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    
                case 'bishop':
                    return Math.abs(targetPos.row - currentPos.row) === Math.abs(targetPos.col - currentPos.col);
                    
                case 'queen':
                    return currentPos.row === targetPos.row || 
                           currentPos.col === targetPos.col || 
                           Math.abs(targetPos.row - currentPos.row) === Math.abs(targetPos.col - currentPos.col);
                    
                case 'king':
                    return Math.abs(targetPos.row - currentPos.row) <= 1 && 
                           Math.abs(targetPos.col - currentPos.col) <= 1;
                    
                default:
                    return false;
            }
        }

        function movePiece(piece, targetPos) {
            const currentPos = getBoardPosition(piece.position);
            const capturedPiece = boardState[targetPos.row][targetPos.col];
            
            // Create animation
            const frameRate = 30;
            const targetPosition = new BABYLON.Vector3(
                targetPos.row - 4 + 0.5,
                piece.position.y,
                targetPos.col - 4 + 0.5
            );
            
            const animation = new BABYLON.Animation(
                "moveAnimation",
                "position",
                frameRate,
                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
            );
            
            const keyFrames = [
                {
                    frame: 0,
                    value: piece.position.clone()
                },
                {
                    frame: frameRate / 2,
                    value: new BABYLON.Vector3(
                        targetPosition.x,
                        piece.position.y + 0.5,
                        targetPosition.z
                    )
                },
                {
                    frame: frameRate,
                    value: targetPosition
                }
            ];
            
            animation.setKeys(keyFrames);
            
            // Update board state
            boardState[currentPos.row][currentPos.col] = null;
            boardState[targetPos.row][targetPos.col] = piece;
            
            // Handle capture
            if (capturedPiece) {
                const fadeAnimation = new BABYLON.Animation(
                    "fadeAnimation",
                    "scaling",
                    frameRate,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
            
                fadeAnimation.setKeys([
                    {
                        frame: 0,
                        value: capturedPiece.scaling.clone()
                    },
                    {
                        frame: frameRate,
                        value: new BABYLON.Vector3(0, 0, 0)
                    }
                ]);
            
                capturedPiece.animations = [fadeAnimation];
                scene.beginAnimation(capturedPiece, 0, frameRate, false, 1, () => {
                    capturedPiece.dispose();
                });
            }
            
            // Begin movement animation
            piece.animations = [animation];
            scene.beginAnimation(piece, 0, frameRate, false, 1, () => {
                // Update game state after animation
                moveCount++;
                const moveText = generateMoveText(piece, currentPos, targetPos, capturedPiece);
                history.push(moveText);
                document.getElementById('history').innerHTML = history.join('<br>');
                
                // Switch turns
                turn = turn === 'white' ? 'black' : 'white';
                
                // Check for checkmate or stalemate
                if (isCheckmate(turn)) {
                    const winner = turn === 'white' ? 'black' : 'white';
                    endGame(winner);
                } else if (isStalemate(turn)) {
                    endGame('draw');
                }
            });
        }

        function updatePieceScales(scale) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const baseScale = 0.5;
                        piece.scaling = new BABYLON.Vector3(
                            baseScale * scale,
                            baseScale * scale,
                            baseScale * scale
                        );
                    }
                }
            }
        }

        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                document.getElementById('startButton').disabled = true;
                document.getElementById('restartButton').disabled = false;
                startTimer();
            }
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (turn === 'white') {
                    whiteTimer--;
                } else {
                    blackTimer--;
                }
                
                updateTimerDisplay();
                
                if (whiteTimer <= 0 || blackTimer <= 0) {
                    endGame(whiteTimer <= 0 ? 'black' : 'white');
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };
            
            document.getElementById('white-timer').textContent = `White: ${formatTime(whiteTimer)}`;
            document.getElementById('black-timer').textContent = `Black: ${formatTime(blackTimer)}`;
        }

            function isValidMove(piece, targetPos) {
                const currentPos = getBoardPosition(piece.position);
                const type = piece.pieceInfo.type.toLowerCase();
                const color = piece.pieceInfo.color;
                
                // Check if moving to same position
                if (currentPos.row === targetPos.row && currentPos.col === targetPos.col) {
                    return false;
                }
                
                // Check if target square has a piece of same color
                const targetPiece = boardState[targetPos.row][targetPos.col];
                if (targetPiece && targetPiece.pieceInfo.color === color) {
                    return false;
                }
                
                // Validate based on piece type
                switch (type) {
                    case 'pawn':
                        return isValidPawnMove(currentPos, targetPos, color, !!targetPiece);
                    case 'rook':
                        return isValidRookMove(currentPos, targetPos);
                    case 'knight':
                        return isValidKnightMove(currentPos, targetPos);
                    case 'bishop':
                        return isValidBishopMove(currentPos, targetPos);
                    case 'queen':
                        return isValidQueenMove(currentPos, targetPos);
                    case 'king':
                        return isValidKingMove(currentPos, targetPos);
                    default:
                        return false;
                }
            }
            
            function isValidPawnMove(current, target, color, isCapture) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Regular move forward
                if (current.col === target.col && !isCapture) {
                    if (target.row === current.row + direction) {
                        return true;
                    }
                    // First move can be two squares
                    if (current.row === startRow && 
                        target.row === current.row + (2 * direction) &&
                        !boardState[current.row + direction][current.col]) {
                        return true;
                    }
                }
                
                // Capture move
                if (isCapture &&
                    target.row === current.row + direction &&
                    Math.abs(target.col - current.col) === 1) {
                    return true;
                }
                
                return false;
            }
            
            function isValidRookMove(current, target) {
                // Rook moves horizontally or vertically
                if (current.row !== target.row && current.col !== target.col) {
                    return false;
                }
                
                return !isPieceBetween(current, target);
            }
            
            function isValidKnightMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // Knight moves in L-shape: 2 squares in one direction and 1 in the other
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }
            
            function isValidBishopMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // Bishop moves diagonally
                if (rowDiff !== colDiff) {
                    return false;
                }
                
                return !isPieceBetween(current, target);
            }
            
            function isValidQueenMove(current, target) {
                // Queen combines rook and bishop movements
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                if (current.row === target.row || current.col === target.col || rowDiff === colDiff) {
                    return !isPieceBetween(current, target);
                }
                
                return false;
            }
            
            function isValidKingMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // King moves one square in any direction
                return rowDiff <= 1 && colDiff <= 1;
            }
            
            function isPieceBetween(current, target) {
                const rowDir = Math.sign(target.row - current.row);
                const colDir = Math.sign(target.col - current.col);
                let row = current.row + rowDir;
                let col = current.col + colDir;
                
                while (row !== target.row || col !== target.col) {
                    if (boardState[row][col]) {
                        return true;
                    }
                    row += rowDir;
                    col += colDir;
                }
                
                return false;
            }
            
            // Update the movePiece function to check for checkmate
            function movePiece(piece, targetPos) {
                const currentPos = getBoardPosition(piece.position);
                const capturedPiece = boardState[targetPos.row][targetPos.col];
                
                // Store move in history
                const moveText = generateMoveText(piece, currentPos, targetPos, capturedPiece);
                
                // Update board state
                boardState[currentPos.row][currentPos.col] = null;
                boardState[targetPos.row][targetPos.col] = piece;
                
                // Move the piece
                piece.position = new BABYLON.Vector3(
                    targetPos.row - 4 + 0.5,
                    piece.position.y,
                    targetPos.col - 4 + 0.5
                );
                
                // If a piece was captured, remove it from the scene
                if (capturedPiece) {
                    capturedPiece.dispose();
                }
                
                // Update game state
                moveCount++;
                history.push(moveText);
                document.getElementById('history').innerHTML = history.join('<br>');
                
                // Switch turns
                turn = turn === 'white' ? 'black' : 'white';
                
                // Check for checkmate or stalemate
                if (isCheckmate(turn)) {
                    const winner = turn === 'white' ? 'black' : 'white';
                    endGame(winner);
                } else if (isStalemate(turn)) {
                    endGame('draw');
                }
            }

            // Create materials for highlighting
            function createHighlightMaterials(scene) {
                // Selected piece highlight
                const selectedMaterial = new BABYLON.StandardMaterial("selectedMat", scene);
                selectedMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.7, 0.2);
                selectedMaterial.alpha = 0.3;
                selectedMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.7, 0.2);
            
                // Valid move highlight
                const validMoveMaterial = new BABYLON.StandardMaterial("validMoveMat", scene);
                validMoveMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
                validMoveMaterial.alpha = 0.3;
                validMoveMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.9);
            
                return { selectedMaterial, validMoveMaterial };
            }
            
            function createHighlightMesh(scene, position, material) {
                const highlight = BABYLON.MeshBuilder.CreateBox(
                    "highlight",
                    { height: 0.1, width: 1, depth: 1 },
                    scene
                );
                highlight.position = new BABYLON.Vector3(
                    position.row - 4 + 0.5,
                    0.1, // Slightly above board
                    position.col - 4 + 0.5
                );
                highlight.material = material;
                return highlight;
            }

            
            // Add these helper functions if they don't exist
            function clearHighlights() {
                // Remove any existing highlight meshes
                scene.meshes.forEach(mesh => {
                    if (mesh.name.startsWith("highlight")) {
                        mesh.dispose();
                    }
                });
            }
            
            function showValidMoves(piece) {
                clearHighlights();
                
                // Check all possible positions
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (isValidMove(piece, { row, col })) {
                            // Create highlight mesh
                            const highlight = BABYLON.MeshBuilder.CreateBox(
                                "highlight_" + row + "_" + col,
                                { height: 0.1, width: 1, depth: 1 },
                                scene
                            );
                            highlight.position = new BABYLON.Vector3(
                                row - 4 + 0.5,
                                0.01, // Slightly above board
                                col - 4 + 0.5
                            );
                            highlight.material = new BABYLON.StandardMaterial("highlightMat", scene);
                            highlight.material.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.2);
                            highlight.material.alpha = 0.3;
                        }
                    }
                }
            }

            
            function setupInteraction(scene) {
                let selectedPiece = null;
                const highlightMaterial = new BABYLON.StandardMaterial("highlightMat", scene);
                highlightMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.2);
                highlightMaterial.alpha = 0.3;
            
                function clearHighlights() {
                    scene.meshes.forEach(mesh => {
                        if (mesh.name.startsWith("highlight")) {
                            mesh.dispose();
                        }
                    });
                }
            
                function showValidMoves(piece) {
                    clearHighlights();
                    
                    const currentPos = getBoardPosition(piece.position);
                    
                    // Highlight selected piece position
                    const selectedHighlight = BABYLON.MeshBuilder.CreateBox(
                        "highlight_selected",
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    selectedHighlight.position = new BABYLON.Vector3(
                        currentPos.row - 4 + 0.5,
                        0.01,
                        currentPos.col - 4 + 0.5
                    );
                    selectedHighlight.material = highlightMaterial;
                    
                    // Show possible moves
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            if (isValidMove(piece, { row, col })) {
                                const highlight = BABYLON.MeshBuilder.CreateBox(
                                    `highlight_${row}_${col}`,
                                    { height: 0.1, width: 1, depth: 1 },
                                    scene
                                );
                                highlight.position = new BABYLON.Vector3(
                                    row - 4 + 0.5,
                                    0.01,
                                    col - 4 + 0.5
                                );
                                highlight.material = highlightMaterial.clone();
                            }
                        }
                    }
                }
            
                scene.onPointerDown = (evt, pickResult) => {
                    if (!gameStarted || gameIsOver) return;
            
                    if (pickResult.hit) {
                        const targetPos = getBoardPosition(pickResult.pickedPoint);
                        
                        if (selectedPiece) {
                            // Attempt to move the selected piece
                            if (isValidMove(selectedPiece, targetPos)) {
                                movePiece(selectedPiece, targetPos);
                                selectedPiece = null;
                                clearHighlights();
                            } else {
                                // If invalid move, check if clicking on another own piece
                                let clickedPiece = null;
                                let currentMesh = pickResult.pickedMesh;
                                while (currentMesh) {
                                    if (currentMesh.pieceInfo) {
                                        clickedPiece = currentMesh;
                                        break;
                                    }
                                    currentMesh = currentMesh.parent;
                                }
                                
                                if (clickedPiece && clickedPiece.pieceInfo.color === turn) {
                                    selectedPiece = clickedPiece;
                                    showValidMoves(selectedPiece);
                                } else {
                                    selectedPiece = null;
                                    clearHighlights();
                                }
                            }
                        } else {
                            // Try to select a piece
                            let currentMesh = pickResult.pickedMesh;
                            while (currentMesh) {
                                if (currentMesh.pieceInfo && currentMesh.pieceInfo.color === turn) {
                                    selectedPiece = currentMesh;
                                    showValidMoves(selectedPiece);
                                    break;
                                }
                                currentMesh = currentMesh.parent;
                            }
                        }
                    }
                };
            }
            
            // Update movePiece function to include animation
            function movePiece(piece, targetPos) {
                const currentPos = getBoardPosition(piece.position);
                const capturedPiece = boardState[targetPos.row][targetPos.col];
                
                // Create animation
                const frameRate = 30;
                const targetPosition = new BABYLON.Vector3(
                    targetPos.row - 4 + 0.5,
                    piece.position.y,
                    targetPos.col - 4 + 0.5
                );
                
                const animation = new BABYLON.Animation(
                    "moveAnimation",
                    "position",
                    frameRate,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
                
                const keyFrames = [
                    {
                        frame: 0,
                        value: piece.position.clone()
                    },
                    {
                        frame: frameRate / 2,
                        value: new BABYLON.Vector3(
                            targetPosition.x,
                            piece.position.y + 0.5, // Lift piece during movement
                            targetPosition.z
                        )
                    },
                    {
                        frame: frameRate,
                        value: targetPosition
                    }
                ];
                
                animation.setKeys(keyFrames);
                
                // Update board state
                boardState[currentPos.row][currentPos.col] = null;
                boardState[targetPos.row][targetPos.col] = piece;
                
                // Handle capture
                if (capturedPiece) {
                    // Fade out animation for captured piece
                    const fadeAnimation = new BABYLON.Animation(
                        "fadeAnimation",
                        "scaling",
                        frameRate,
                        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );
                    
                    fadeAnimation.setKeys([
                        {
                            frame: 0,
                            value: capturedPiece.scaling.clone()
                        },
                        {
                            frame: frameRate,
                            value: new BABYLON.Vector3(0, 0, 0)
                        }
                    ]);
                    
                    capturedPiece.animations = [fadeAnimation];
                    scene.beginAnimation(capturedPiece, 0, frameRate, false, 1, () => {
                        capturedPiece.dispose();
                    });
                }
                
                // Begin movement animation
                piece.animations = [animation];
                scene.beginAnimation(piece, 0, frameRate, false, 1, () => {
                    // Update game state after animation
                    moveCount++;
                    const moveText = generateMoveText(piece, currentPos, targetPos, capturedPiece);
                    history.push(moveText);
                    document.getElementById('history').innerHTML = history.join('<br>');
                    
                    // Switch turns
                    turn = turn === 'white' ? 'black' : 'white';
                    
                    // Check for checkmate or stalemate
                    if (isCheckmate(turn)) {
                        const winner = turn === 'white' ? 'black' : 'white';
                        endGame(winner);
                    } else if (isStalemate(turn)) {
                        endGame('draw');
                    }
                });
            }
            
            function generateMoveText(piece, from, to, capturedPiece) {
                const pieceSymbol = piece.pieceInfo.type.charAt(0).toUpperCase();
                const fromSquare = `${String.fromCharCode(97 + from.col)}${8 - from.row}`;
                const toSquare = `${String.fromCharCode(97 + to.col)}${8 - to.row}`;
                const captureText = capturedPiece ? 'x' : '';
                
                return `${moveCount + 1}. ${piece.pieceInfo.color} ${pieceSymbol}${fromSquare}${captureText}${toSquare}`;
            }
            
            function isCheckmate(color) {
                const king = findKing(color);
                if (!king) return true;
                
                const kingPos = getBoardPosition(king.position);
                
                // Check if the king has any legal moves
                for (let row = -1; row <= 1; row++) {
                    for (let col = -1; col <= 1; col++) {
                        const targetRow = kingPos.row + row;
                        const targetCol = kingPos.col + col;
                        
                        if (targetRow >= 0 && targetRow < 8 && targetCol >= 0 && targetCol < 8) {
                            if (isValidMove(king, { row: targetRow, col: targetCol })) {
                                return false;
                            }
                        }
                    }
                }
                
                // Check if any of the player's pieces can make a valid move
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = boardState[i][j];
                        if (piece && piece.pieceInfo.color === color) {
                            for (let targetRow = 0; targetRow < 8; targetRow++) {
                                for (let targetCol = 0; targetCol < 8; targetCol++) {
                                    if (isValidMove(piece, { row: targetRow, col: targetCol })) {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            
            function isStalemate(color) {
                const king = findKing(color);
                if (!king) return false;
                
                const kingPos = getBoardPosition(king.position);
                
                // Check if the king has any legal moves
                for (let row = -1; row <= 1; row++) {
                    for (let col = -1; col <= 1; col++) {
                        const targetRow = kingPos.row + row;
                        const targetCol = kingPos.col + col;
                        
                        if (targetRow >= 0 && targetRow < 8 && targetCol >= 0 && targetCol < 8) {
                            if (isValidMove(king, { row: targetRow, col: targetCol })) {
                                return false;
                            }
                        }
                    }
                }
                
                // Check if any of the player's pieces can make a valid move
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = boardState[i][j];
                        if (piece && piece.pieceInfo.color === color) {
                            for (let targetRow = 0; targetRow < 8; targetRow++) {
                                for (let targetCol = 0; targetCol < 8; targetCol++) {
                                    if (isValidMove(piece, { row: targetRow, col: targetCol })) {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
                
                return true;
            }
            
            function findKing(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && 
                            piece.pieceInfo.type.toLowerCase() === 'king' && 
                            piece.pieceInfo.color === color) {
                            return piece;
                        }
                    }
                }
                return null;
            }


        function endGame(winner) {
            gameIsOver = true;
            clearInterval(timerInterval);
            history.push(`Game Over - ${winner} wins!`);
            document.getElementById('history').innerHTML = history.join('<br>');
            alert(`Game Over - ${winner} wins!`);
        }

        // Initialize the scene and game
        createScene().then(newScene => {
            scene = newScene;
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Event listeners
        window.addEventListener('resize', () => {
            engine.resize();
        });

        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', () => {
            location.reload();
        });
        document.getElementById('exportButton').addEventListener('click', () => {
            BABYLON.GLTF2Export.GLBAsync(scene, "chess_game").then((glb) => {
                glb.downloadFiles();
            });
        });

        const scaleSlider = document.getElementById('pieceScale');
        const scaleValue = document.getElementById('scaleValue');
        
        if (scaleSlider && scaleValue) {
            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                scaleValue.textContent = newScale.toFixed(1);
                updatePieceScales(newScale);
            });
        }
    </script>
</body>
</html>
