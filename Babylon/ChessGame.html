<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTF2Serializer.min.js"></script>
    <style>
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .board-container {
            flex-shrink: 0;
        }
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .scale-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .scale-controls input {
            width: 200px;
        }
        .scale-controls label {
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #renderCanvas {
            border: 1px solid #000;
            width: 600px;
            height: 600px;
            touch-action: none;
        }
        .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #history {
            flex-grow: 1;
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="game-controls">
                <button id="startButton">Start Game</button>
                <button id="restartButton" disabled>Restart Game</button>
                <button id="exportButton">Export GLB</button>
            </div>
            
            <div class="scale-controls">
                <label for="pieceScale">Piece Scale:</label>
                <input type="range" id="pieceScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="scaleValue">1.0</span>
            </div>
            
            <div id="hud">
                <div id="white-timer">White: 05:00</div>
                <div id="black-timer">Black: 05:00</div>
            </div>
            
            <canvas id="renderCanvas"></canvas>
        </div>
        <div class="history-container">
            <h2>Move History</h2>
            <div id="history"></div>
        </div>
    </div>

        <script>
        // Global variables
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let gameStarted = false;
        let gameIsOver = false;
        let selectedPiece = null;
        let turn = 'white';
        let moveCount = 0;
        let history = [];
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let whiteTimer = 300; // 5 minutes in seconds
        let blackTimer = 300;
        let timerInterval;
        let scene;

        // Create the 3D scene
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                12,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 20;
            
            // Lighting
            const light = new BABYLON.HemisphericLight(
                "light",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            
            // Create chessboard
            createChessboard(scene);
            
            // Create and position pieces
            await setupPieces(scene);
            
            // Setup interaction
            setupInteraction(scene);
            
            return scene;
        }

        function createChessboard(scene) {
            const boardMaterial = new BABYLON.StandardMaterial("boardMat", scene);
            boardMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            
            // Create board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = BABYLON.MeshBuilder.CreateBox(
                        `square_${row}_${col}`,
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    
                    square.position = new BABYLON.Vector3(
                        row - 4 + 0.5,
                        -0.05,
                        col - 4 + 0.5
                    );
                    
                    const material = new BABYLON.StandardMaterial(
                        `squareMat_${row}_${col}`,
                        scene
                    );
                    material.diffuseColor = (row + col) % 2 === 0
                        ? new BABYLON.Color3(1, 1, 1)
                        : new BABYLON.Color3(0.4, 0.4, 0.4);
                    
                    square.material = material;
                    square.boardPosition = { row, col };
                }
            }
        }

        async function loadPieceModel(scene, type) {
            const modelMap = {
                'pawn': 'pawn.glb',
                'rook': 'rook.glb',
                'knight': 'knight.glb',
                'bishop': 'bishop.glb',
                'queen': 'queen.glb',
                'king': 'chess_king.glb'
            };

            const fileName = modelMap[type.toLowerCase()];
            if (!fileName) {
                throw new Error(`Unknown piece type: ${type}`);
            }

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    "",
                    "./",
                    fileName,
                    scene
                );

                const rootMesh = result.meshes[0];
                const container = new BABYLON.Mesh("container", scene);
                
                result.meshes.forEach(mesh => {
                    if (mesh !== rootMesh) {
                        mesh.parent = container;
                    }
                });

                container.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);

                const boundingBox = container.getHierarchyBoundingVectors(true);
                const dimensions = boundingBox.max.subtract(boundingBox.min);
                const centerOffset = dimensions.scale(0.5);
                container.position.y = -boundingBox.min.y;

                return container;
            } catch (error) {
                console.error(`Error loading model ${fileName}:`, error);
                throw error;
            }
        }

        async function createPiece(scene, type, row, col, color) {
            const piece = await loadPieceModel(scene, type);
            
            piece.position = new BABYLON.Vector3(
                row - 4 + 0.5,
                0,
                col - 4 + 0.5
            );
            
            const material = new BABYLON.StandardMaterial(`${color}${type}Mat`, scene);
            material.diffuseColor = color === 'white'
                ? new BABYLON.Color3(0.9, 0.9, 0.9)
                : new BABYLON.Color3(0.2, 0.2, 0.2);
            
            piece.getChildMeshes().forEach(mesh => {
                mesh.material = material;
            });
            
            piece.pieceInfo = { type, color };
            boardState[row][col] = piece;
            
            return piece;
        }

        async function setupPieces(scene) {
            const pieces = [
                { type: 'rook', positions: [[0, 0], [0, 7], [7, 0], [7, 7]] },
                { type: 'knight', positions: [[0, 1], [0, 6], [7, 1], [7, 6]] },
                { type: 'bishop', positions: [[0, 2], [0, 5], [7, 2], [7, 5]] },
                { type: 'queen', positions: [[0, 3], [7, 3]] },
                { type: 'king', positions: [[0, 4], [7, 4]] }
            ];
            
            // Create pawns
            for (let col = 0; col < 8; col++) {
                await createPiece(scene, 'pawn', 1, col, 'black');
                await createPiece(scene, 'pawn', 6, col, 'white');
            }
            
            // Create other pieces
            for (const piece of pieces) {
                for (const [row, col] of piece.positions) {
                    const color = row === 0 ? 'black' : 'white';
                    await createPiece(scene, piece.type, row, col, color);
                }
            }
        }

        function setupInteraction(scene) {
            scene.onPointerDown = function(evt, pickResult) {
                if (!gameStarted || gameIsOver) return;

                if (pickResult.hit) {
                    const mesh = pickResult.pickedMesh;
                    const boardPos = getBoardPosition(mesh.position);
                    
                    if (selectedPiece) {
                        // Try to move the selected piece
                        if (isValidMove(selectedPiece, boardPos)) {
                            movePiece(selectedPiece, boardPos);
                            selectedPiece = null;
                        } else {
                            // Deselect if invalid move
                            selectedPiece = null;
                        }
                    } else {
                        // Select a piece
                        const piece = boardState[boardPos.row][boardPos.col];
                        if (piece && piece.pieceInfo.color === turn) {
                            selectedPiece = piece;
                        }
                    }
                }
            };
        }

        function getBoardPosition(position) {
            const row = Math.floor(position.x + 4);
            const col = Math.floor(position.z + 4);
            return { row, col };
        }

        function isValidMove(piece, targetPos) {
            const currentPos = getBoardPosition(piece.position);
            // Implement chess rules here
            // This is a simplified version that allows any move
            return true;
        }

        function movePiece(piece, targetPos) {
            const currentPos = getBoardPosition(piece.position);
            
            // Update board state
            boardState[currentPos.row][currentPos.col] = null;
            boardState[targetPos.row][targetPos.col] = piece;
            
            // Move the piece
            piece.position = new BABYLON.Vector3(
                targetPos.row - 4 + 0.5,
                piece.position.y,
                targetPos.col - 4 + 0.5
            );
            
            // Update game state
            moveCount++;
            const moveText = `${moveCount}. ${piece.pieceInfo.color} ${piece.pieceInfo.type} to ${String.fromCharCode(97 + targetPos.col)}${8 - targetPos.row}`;
            history.push(moveText);
            document.getElementById('history').innerHTML = history.join('<br>');
            
            // Switch turns
            turn = turn === 'white' ? 'black' : 'white';
        }

        function updatePieceScales(scale) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const baseScale = 0.5;
                        piece.scaling = new BABYLON.Vector3(
                            baseScale * scale,
                            baseScale * scale,
                            baseScale * scale
                        );
                    }
                }
            }
        }

        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                document.getElementById('startButton').disabled = true;
                document.getElementById('restartButton').disabled = false;
                startTimer();
            }
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (turn === 'white') {
                    whiteTimer--;
                } else {
                    blackTimer--;
                }
                
                updateTimerDisplay();
                
                if (whiteTimer <= 0 || blackTimer <= 0) {
                    endGame(whiteTimer <= 0 ? 'black' : 'white');
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };
            
            document.getElementById('white-timer').textContent = `White: ${formatTime(whiteTimer)}`;
            document.getElementById('black-timer').textContent = `Black: ${formatTime(blackTimer)}`;
        }

        function endGame(winner) {
            gameIsOver = true;
            clearInterval(timerInterval);
            history.push(`Game Over - ${winner} wins!`);
            document.getElementById('history').innerHTML = history.join('<br>');
            alert(`Game Over - ${winner} wins!`);
        }

        // Initialize the scene and game
        createScene().then(newScene => {
            scene = newScene;
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Event listeners
        window.addEventListener('resize', () => {
            engine.resize();
        });

        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', () => {
            location.reload();
        });
        document.getElementById('exportButton').addEventListener('click', () => {
            BABYLON.GLTF2Export.GLBAsync(scene, "chess_game").then((glb) => {
                glb.downloadFiles();
            });
        });

        const scaleSlider = document.getElementById('pieceScale');
        const scaleValue = document.getElementById('scaleValue');
        
        if (scaleSlider && scaleValue) {
            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                scaleValue.textContent = newScale.toFixed(1);
                updatePieceScales(newScale);
            });
        }
    </script>
</body>
</html>
