<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTF2Serializer.min.js"></script>
    <style>
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .board-container {
            flex-shrink: 0;
        }
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .scale-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .scale-controls input {
            width: 200px;
        }
        .scale-controls label {
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #renderCanvas {
            border: 1px solid #000;
            width: 600px;
            height: 600px;
            touch-action: none;
        }
        .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #history {
            flex-grow: 1;
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="game-controls">
                <button id="startButton">Start Game</button>
                <button id="restartButton" disabled>Restart Game</button>
                <button id="exportButton">Export GLB</button>
            </div>
            
            <div class="scale-controls">
                <label for="pieceScale">Piece Scale:</label>
                <input type="range" id="pieceScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="scaleValue">1.0</span>
            </div>
            
            <div id="hud">
                <div id="white-timer">White: 05:00</div>
                <div id="black-timer">Black: 05:00</div>
            </div>
            
            <canvas id="renderCanvas"></canvas>
        </div>
        <div class="history-container">
            <h2>Move History</h2>
            <div id="history"></div>
        </div>
    </div>

    <script>
        // Global variables
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let gameStarted = false;
        let gameIsOver = false;
        let selectedPiece = null;
        let turn = 'white';
        let moveCount = 0;
        let history = [];
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let whiteTimer = 300; // 5 minutes in seconds
        let blackTimer = 300;
        let timerInterval;
        
        // Create the 3D scene
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                12,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 20;
            
            // Lighting
            const light = new BABYLON.HemisphericLight(
                "light",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            
            // Create chessboard
            createChessboard(scene);
            
            // Create and position pieces
            await setupPieces(scene);
            
            // Setup interaction
            setupInteraction(scene);
            
            return scene;
        }
        
        function createChessboard(scene) {
            const boardMaterial = new BABYLON.StandardMaterial("boardMat", scene);
            boardMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            
            // Create board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = BABYLON.MeshBuilder.CreateBox(
                        `square_${row}_${col}`,
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    
                    square.position = new BABYLON.Vector3(
                        row - 4 + 0.5,
                        -0.05,
                        col - 4 + 0.5
                    );
                    
                    const material = new BABYLON.StandardMaterial(
                        `squareMat_${row}_${col}`,
                        scene
                    );
                    material.diffuseColor = (row + col) % 2 === 0
                        ? new BABYLON.Color3(1, 1, 1)
                        : new BABYLON.Color3(0.4, 0.4, 0.4);
                    
                    square.material = material;
                    square.boardPosition = { row, col };
                }
            }
        }

        // Piece models - using basic shapes for now
        async function loadPieceModel(scene, type) {
            const height = type === 'pawn' ? 0.8 : 1.2;
            let mesh;
            
            switch (type.toLowerCase()) {
                case 'pawn':
                    mesh = BABYLON.MeshBuilder.CreateCylinder(
                        "pawn",
                        { height: height, diameter: 0.3 },
                        scene
                    );
                    break;
                case 'rook':
                    mesh = BABYLON.MeshBuilder.CreateBox(
                        "rook",
                        { height: height, width: 0.4, depth: 0.4 },
                        scene
                    );
                    break;
                case 'knight':
                    mesh = BABYLON.MeshBuilder.CreateCylinder(
                        "knight",
                        { height: height, diameter: 0.4, diameterTop: 0.2 },
                        scene
                    );
                    break;
                case 'bishop':
                    mesh = BABYLON.MeshBuilder.CreateCone(
                        "bishop",
                        { height: height, diameter: 0.4 },
                        scene
                    );
                    break;
                case 'queen':
                    mesh = BABYLON.MeshBuilder.CreateSphere(
                        "queen",
                        { diameter: 0.5, segments: 16 },
                        scene
                    );
                    mesh.scaling.y = 2;
                    break;
                case 'king':
                    const base = BABYLON.MeshBuilder.CreateCylinder(
                        "kingBase",
                        { height: height, diameter: 0.4 },
                        scene
                    );
                    const cross = BABYLON.MeshBuilder.CreateBox(
                        "kingCross",
                        { height: 0.3, width: 0.1, depth: 0.1 },
                        scene
                    );
                    cross.position.y = height / 2 + 0.1;
                    const crossHorizontal = BABYLON.MeshBuilder.CreateBox(
                        "kingCrossHorizontal",
                        { height: 0.1, width: 0.3, depth: 0.1 },
                        scene
                    );
                    crossHorizontal.position.y = height / 2 + 0.1;
                    
                    mesh = BABYLON.Mesh.MergeMeshes(
                        [base, cross, crossHorizontal],
                        true
                    );
                    break;
            }
            
            mesh.position.y = height / 2;
            return mesh;
        }

        async function setupPieces(scene) {
            const pieces = [
                { type: 'rook', positions: [[0, 0], [0, 7], [7, 0], [7, 7]] },
                { type: 'knight', positions: [[0, 1], [0, 6], [7, 1], [7, 6]] },
                { type: 'bishop', positions: [[0, 2], [0, 5], [7, 2], [7, 5]] },
                { type: 'queen', positions: [[0, 3], [7, 3]] },
                { type: 'king', positions: [[0, 4], [7, 4]] }
            ];
            
            // Create pawns
            for (let col = 0; col < 8; col++) {
                await createPiece(scene, 'pawn', 1, col, 'black');
                await createPiece(scene, 'pawn', 6, col, 'white');
            }
            
            // Create other pieces
            for (const piece of pieces) {
                for (const [row, col] of piece.positions) {
                    const color = row === 0 ? 'black' : 'white';
                    await createPiece(scene, piece.type, row, col, color);
                }
            }
        }

        async function createPiece(scene, type, row, col, color) {
            const piece = await loadPieceModel(scene, type);
            piece.position = new BABYLON.Vector3(
                row - 4 + 0.5,
                piece.position.y,
                col - 4 + 0.5
            );
            
            const material = new BABYLON.StandardMaterial(`${color}${type}Mat`, scene);
            material.diffuseColor = color === 'white'
                ? new BABYLON.Color3(0.9, 0.9, 0.9)
                : new BABYLON.Color3(0.2, 0.2, 0.2);
            piece.material = material;
            
            piece.pieceInfo = { type, color };
            boardState[row][col] = piece;
            
            return piece;
        }

        function updatePieceScales(scale) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        piece.scaling = new BABYLON.Vector3(scale, scale, scale);
                    }
                }
            }
        }

        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                document.getElementById('startButton').disabled = true;
                document.getElementById('restartButton').disabled = false;
                startTimer();
            }
        }

        function restartGame() {
            location.reload();
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (turn === 'white') {
                    whiteTimer--;
                } else {
                    blackTimer--;
                }
                
                updateTimerDisplay();
                
                if (whiteTimer <= 0 || blackTimer <= 0) {
                    endGame(whiteTimer <= 0 ? 'black' : 'white');
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };
            
            document.getElementById('white-timer').textContent = `White: ${formatTime(whiteTimer)}`;
            document.getElementById('black-timer').textContent = `Black: ${formatTime(blackTimer)}`;
        }

        function endGame(winner) {
            gameIsOver = true;
            clearInterval(timerInterval);
            history.push(`Game Over - ${winner} wins!`);
            document.getElementById('history').innerHTML = history.join('<br>');
            alert(`Game Over - ${winner} wins!`);
        }

        // Initialize the scene and game
        let scene;
        createScene().then(newScene => {
            scene = newScene;
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            engine.resize();
        });

        // Event listeners
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('exportButton').addEventListener('click', () => {
            BABYLON.GLTF2Export.GLBAsync(scene, "chess_game").then((glb) => {
                glb.downloadFiles();
            });
        });

        const scaleSlider = document.getElementById('pieceScale');
        const scaleValue = document.getElementById('scaleValue');
        
        if (scaleSlider && scaleValue) {
            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                scaleValue.textContent = newScale.toFixed(1);
                updatePieceScales(newScale);
            });
        }
    </script>
</body>
</html>
