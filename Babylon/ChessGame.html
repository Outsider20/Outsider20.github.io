<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTF2Serializer.min.js"></script>
    <style>
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .board-container {
            flex-shrink: 0;
        }
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .scale-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .scale-controls input {
            width: 200px;
        }
        .scale-controls label {
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #renderCanvas {
            border: 1px solid #000;
            width: 600px;
            height: 600px;
            touch-action: none;
        }
        .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #history {
            flex-grow: 1;
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="game-controls">
                <button id="startButton">Start Game</button>
                <button id="restartButton" disabled>Restart Game</button>
                <button id="exportButton">Export GLB</button>
            </div>
            
            <div class="scale-controls">
                <label for="pieceScale">Piece Scale:</label>
                <input type="range" id="pieceScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="scaleValue">1.0</span>
            </div>
            
            <div id="hud">
                <div id="white-timer">White: 05:00</div>
                <div id="black-timer">Black: 05:00</div>
            </div>
            
            <canvas id="renderCanvas"></canvas>
        </div>
        <div class="history-container">
            <h2>Move History</h2>
            <div id="history"></div>
        </div>
    </div>

        <script>
        // Global variables
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let gameStarted = false;
        let gameIsOver = false;
        let selectedPiece = null;
        let turn = 'white';
        let moveCount = 0;
        let history = [];
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let whiteTimer = 300; // 5 minutes in seconds
        let blackTimer = 300;
        let timerInterval;
        let scene;

        // Create the 3D scene
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                12,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 20;
            
            // Lighting
            const light = new BABYLON.HemisphericLight(
                "light",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            
            // Create chessboard
            createChessboard(scene);
            
            // Create and position pieces
            await setupPieces(scene);
            
            // Setup interaction
            setupInteraction(scene);
            
            return scene;
        }

        function createChessboard(scene) {
            const boardMaterial = new BABYLON.StandardMaterial("boardMat", scene);
            boardMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            
            // Create board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = BABYLON.MeshBuilder.CreateBox(
                        `square_${row}_${col}`,
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    
                    square.position = new BABYLON.Vector3(
                        row - 4 + 0.5,
                        -0.05,
                        col - 4 + 0.5
                    );
                    
                    const material = new BABYLON.StandardMaterial(
                        `squareMat_${row}_${col}`,
                        scene
                    );
                    material.diffuseColor = (row + col) % 2 === 0
                        ? new BABYLON.Color3(1, 1, 1)
                        : new BABYLON.Color3(0.4, 0.4, 0.4);
                    
                    square.material = material;
                    square.boardPosition = { row, col };
                }
            }
        }

        async function loadPieceModel(scene, type) {
            const modelMap = {
                'pawn': 'pawn.glb',
                'rook': 'rook.glb',
                'knight': 'knight.glb',
                'bishop': 'bishop.glb',
                'queen': 'queen.glb',
                'king': 'chess_king.glb'
            };

            const fileName = modelMap[type.toLowerCase()];
            if (!fileName) {
                throw new Error(`Unknown piece type: ${type}`);
            }

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    "",
                    "./",
                    fileName,
                    scene
                );

                const rootMesh = result.meshes[0];
                const container = new BABYLON.Mesh("container", scene);
                
                result.meshes.forEach(mesh => {
                    if (mesh !== rootMesh) {
                        mesh.parent = container;
                    }
                });

                container.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);

                const boundingBox = container.getHierarchyBoundingVectors(true);
                const dimensions = boundingBox.max.subtract(boundingBox.min);
                const centerOffset = dimensions.scale(0.5);
                container.position.y = -boundingBox.min.y;

                return container;
            } catch (error) {
                console.error(`Error loading model ${fileName}:`, error);
                throw error;
            }
        }

        async function createPiece(scene, type, row, col, color) {
            const piece = await loadPieceModel(scene, type);
            
            piece.position = new BABYLON.Vector3(
                row - 4 + 0.5,
                0,
                col - 4 + 0.5
            );
            
            const material = new BABYLON.StandardMaterial(`${color}${type}Mat`, scene);
            material.diffuseColor = color === 'white'
                ? new BABYLON.Color3(0.9, 0.9, 0.9)
                : new BABYLON.Color3(0.2, 0.2, 0.2);
            
            piece.getChildMeshes().forEach(mesh => {
                mesh.material = material;
            });
            
            piece.pieceInfo = { type, color };
            boardState[row][col] = piece;
            
            return piece;
        }

        async function setupPieces(scene) {
            const pieces = [
                { type: 'rook', positions: [[0, 0], [0, 7], [7, 0], [7, 7]] },
                { type: 'knight', positions: [[0, 1], [0, 6], [7, 1], [7, 6]] },
                { type: 'bishop', positions: [[0, 2], [0, 5], [7, 2], [7, 5]] },
                { type: 'queen', positions: [[0, 3], [7, 3]] },
                { type: 'king', positions: [[0, 4], [7, 4]] }
            ];
            
            // Create pawns
            for (let col = 0; col < 8; col++) {
                await createPiece(scene, 'pawn', 1, col, 'black');
                await createPiece(scene, 'pawn', 6, col, 'white');
            }
            
            // Create other pieces
            for (const piece of pieces) {
                for (const [row, col] of piece.positions) {
                    const color = row === 0 ? 'black' : 'white';
                    await createPiece(scene, piece.type, row, col, color);
                }
            }
        }

        function setupInteraction(scene) {
            scene.onPointerDown = function(evt, pickResult) {
                if (!gameStarted || gameIsOver) return;

                if (pickResult.hit) {
                    const mesh = pickResult.pickedMesh;
                    const boardPos = getBoardPosition(mesh.position);
                    
                    if (selectedPiece) {
                        // Try to move the selected piece
                        if (isValidMove(selectedPiece, boardPos)) {
                            movePiece(selectedPiece, boardPos);
                            selectedPiece = null;
                        } else {
                            // Deselect if invalid move
                            selectedPiece = null;
                        }
                    } else {
                        // Select a piece
                        const piece = boardState[boardPos.row][boardPos.col];
                        if (piece && piece.pieceInfo.color === turn) {
                            selectedPiece = piece;
                        }
                    }
                }
            };
        }

        function getBoardPosition(position) {
            const row = Math.floor(position.x + 4);
            const col = Math.floor(position.z + 4);
            return { row, col };
        }

        function isValidMove(piece, targetPos) {
            const currentPos = getBoardPosition(piece.position);
            // Implement chess rules here
            // This is a simplified version that allows any move
            return true;
        }

        function movePiece(piece, targetPos) {
            const currentPos = getBoardPosition(piece.position);
            
            // Update board state
            boardState[currentPos.row][currentPos.col] = null;
            boardState[targetPos.row][targetPos.col] = piece;
            
            // Move the piece
            piece.position = new BABYLON.Vector3(
                targetPos.row - 4 + 0.5,
                piece.position.y,
                targetPos.col - 4 + 0.5
            );
            
            // Update game state
            moveCount++;
            const moveText = `${moveCount}. ${piece.pieceInfo.color} ${piece.pieceInfo.type} to ${String.fromCharCode(97 + targetPos.col)}${8 - targetPos.row}`;
            history.push(moveText);
            document.getElementById('history').innerHTML = history.join('<br>');
            
            // Switch turns
            turn = turn === 'white' ? 'black' : 'white';
        }

        function updatePieceScales(scale) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const baseScale = 0.5;
                        piece.scaling = new BABYLON.Vector3(
                            baseScale * scale,
                            baseScale * scale,
                            baseScale * scale
                        );
                    }
                }
            }
        }

        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                document.getElementById('startButton').disabled = true;
                document.getElementById('restartButton').disabled = false;
                startTimer();
            }
        }

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                if (turn === 'white') {
                    whiteTimer--;
                } else {
                    blackTimer--;
                }
                
                updateTimerDisplay();
                
                if (whiteTimer <= 0 || blackTimer <= 0) {
                    endGame(whiteTimer <= 0 ? 'black' : 'white');
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };
            
            document.getElementById('white-timer').textContent = `White: ${formatTime(whiteTimer)}`;
            document.getElementById('black-timer').textContent = `Black: ${formatTime(blackTimer)}`;
        }

            function isValidMove(piece, targetPos) {
                const currentPos = getBoardPosition(piece.position);
                const type = piece.pieceInfo.type.toLowerCase();
                const color = piece.pieceInfo.color;
                
                // Check if moving to same position
                if (currentPos.row === targetPos.row && currentPos.col === targetPos.col) {
                    return false;
                }
                
                // Check if target square has a piece of same color
                const targetPiece = boardState[targetPos.row][targetPos.col];
                if (targetPiece && targetPiece.pieceInfo.color === color) {
                    return false;
                }
                
                // Validate based on piece type
                switch (type) {
                    case 'pawn':
                        return isValidPawnMove(currentPos, targetPos, color, !!targetPiece);
                    case 'rook':
                        return isValidRookMove(currentPos, targetPos);
                    case 'knight':
                        return isValidKnightMove(currentPos, targetPos);
                    case 'bishop':
                        return isValidBishopMove(currentPos, targetPos);
                    case 'queen':
                        return isValidQueenMove(currentPos, targetPos);
                    case 'king':
                        return isValidKingMove(currentPos, targetPos);
                    default:
                        return false;
                }
            }
            
            function isValidPawnMove(current, target, color, isCapture) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Regular move forward
                if (current.col === target.col && !isCapture) {
                    if (target.row === current.row + direction) {
                        return true;
                    }
                    // First move can be two squares
                    if (current.row === startRow && 
                        target.row === current.row + (2 * direction) &&
                        !boardState[current.row + direction][current.col]) {
                        return true;
                    }
                }
                
                // Capture move
                if (isCapture &&
                    target.row === current.row + direction &&
                    Math.abs(target.col - current.col) === 1) {
                    return true;
                }
                
                return false;
            }
            
            function isValidRookMove(current, target) {
                // Rook moves horizontally or vertically
                if (current.row !== target.row && current.col !== target.col) {
                    return false;
                }
                
                return !isPieceBetween(current, target);
            }
            
            function isValidKnightMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // Knight moves in L-shape: 2 squares in one direction and 1 in the other
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }
            
            function isValidBishopMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // Bishop moves diagonally
                if (rowDiff !== colDiff) {
                    return false;
                }
                
                return !isPieceBetween(current, target);
            }
            
            function isValidQueenMove(current, target) {
                // Queen combines rook and bishop movements
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                if (current.row === target.row || current.col === target.col || rowDiff === colDiff) {
                    return !isPieceBetween(current, target);
                }
                
                return false;
            }
            
            function isValidKingMove(current, target) {
                const rowDiff = Math.abs(target.row - current.row);
                const colDiff = Math.abs(target.col - current.col);
                
                // King moves one square in any direction
                return rowDiff <= 1 && colDiff <= 1;
            }
            
            function isPieceBetween(current, target) {
                const rowDir = Math.sign(target.row - current.row);
                const colDir = Math.sign(target.col - current.col);
                let row = current.row + rowDir;
                let col = current.col + colDir;
                
                while (row !== target.row || col !== target.col) {
                    if (boardState[row][col]) {
                        return true;
                    }
                    row += rowDir;
                    col += colDir;
                }
                
                return false;
            }
            
            // Update the movePiece function to check for checkmate
            function movePiece(piece, targetPos) {
                const currentPos = getBoardPosition(piece.position);
                const capturedPiece = boardState[targetPos.row][targetPos.col];
                
                // Store move in history
                const moveText = generateMoveText(piece, currentPos, targetPos, capturedPiece);
                
                // Update board state
                boardState[currentPos.row][currentPos.col] = null;
                boardState[targetPos.row][targetPos.col] = piece;
                
                // Move the piece
                piece.position = new BABYLON.Vector3(
                    targetPos.row - 4 + 0.5,
                    piece.position.y,
                    targetPos.col - 4 + 0.5
                );
                
                // If a piece was captured, remove it from the scene
                if (capturedPiece) {
                    capturedPiece.dispose();
                }
                
                // Update game state
                moveCount++;
                history.push(moveText);
                document.getElementById('history').innerHTML = history.join('<br>');
                
                // Switch turns
                turn = turn === 'white' ? 'black' : 'white';
                
                // Check for checkmate or stalemate
                if (isCheckmate(turn)) {
                    const winner = turn === 'white' ? 'black' : 'white';
                    endGame(winner);
                } else if (isStalemate(turn)) {
                    endGame('draw');
                }
            }
            
            function generateMoveText(piece, from, to, capturedPiece) {
                const pieceSymbol = piece.pieceInfo.type.charAt(0).toUpperCase();
                const fromSquare = `${String.fromCharCode(97 + from.col)}${8 - from.row}`;
                const toSquare = `${String.fromCharCode(97 + to.col)}${8 - to.row}`;
                const captureText = capturedPiece ? 'x' : '';
                
                return `${moveCount + 1}. ${piece.pieceInfo.color} ${pieceSymbol}${fromSquare}${captureText}${toSquare}`;
            }
            
            function isCheckmate(color) {
                // For simplicity, we'll just check if the king has any legal moves
                // A full implementation would need to check if any piece can prevent checkmate
                const king = findKing(color);
                if (!king) return true;
                
                const kingPos = getBoardPosition(king.position);
                
                // Check all possible king moves
                for (let row = -1; row <= 1; row++) {
                    for (let col = -1; col <= 1; col++) {
                        const targetRow = kingPos.row + row;
                        const targetCol = kingPos.col + col;
                        
                        if (targetRow >= 0 && targetRow < 8 && targetCol >= 0 && targetCol < 8) {
                            if (isValidMove(king, { row: targetRow, col: targetCol })) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            function isStalemate(color) {
                // Similar to checkmate check, but simpler for this implementation
                return isCheckmate(color);
            }
            
            function findKing(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = boardState[row][col];
                        if (piece && 
                            piece.pieceInfo.type.toLowerCase() === 'king' && 
                            piece.pieceInfo.color === color) {
                            return piece;
                        }
                    }
                }
                return null;
            }


        function endGame(winner) {
            gameIsOver = true;
            clearInterval(timerInterval);
            history.push(`Game Over - ${winner} wins!`);
            document.getElementById('history').innerHTML = history.join('<br>');
            alert(`Game Over - ${winner} wins!`);
        }

        // Initialize the scene and game
        createScene().then(newScene => {
            scene = newScene;
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Event listeners
        window.addEventListener('resize', () => {
            engine.resize();
        });

        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', () => {
            location.reload();
        });
        document.getElementById('exportButton').addEventListener('click', () => {
            BABYLON.GLTF2Export.GLBAsync(scene, "chess_game").then((glb) => {
                glb.downloadFiles();
            });
        });

        const scaleSlider = document.getElementById('pieceScale');
        const scaleValue = document.getElementById('scaleValue');
        
        if (scaleSlider && scaleValue) {
            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                scaleValue.textContent = newScale.toFixed(1);
                updatePieceScales(newScale);
            });
        }
    </script>
</body>
</html>
