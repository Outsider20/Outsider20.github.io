<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylon.glTF2Serializer.min.js"></script>
    <style>
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .board-container {
            flex-shrink: 0;
        }
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .scale-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .scale-controls input {
            width: 200px;
        }
        .scale-controls label {
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #renderCanvas {
            border: 1px solid #000;
            width: 600px;
            height: 600px;
            touch-action: none;
        }
        .history-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #history {
            flex-grow: 1;
            width: 300px;
            height: 400px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            font-family: Arial, sans-serif;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="game-controls">
                <button id="startButton">Start Game</button>
                <button id="restartButton" disabled>Restart Game</button>
                <button id="exportButton">Export GLB</button>
            </div>
            
            <div class="scale-controls">
                <label for="pieceScale">Piece Scale:</label>
                <input type="range" id="pieceScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <span id="scaleValue">1.0</span>
            </div>
            
            <div id="hud">
                <div id="white-timer">White: 05:00</div>
                <div id="black-timer">Black: 05:00</div>
            </div>
            
            <canvas id="renderCanvas"></canvas>
        </div>
        <div class="history-container">
            <h2>Move History</h2>
            <div id="history"></div>
        </div>
    </div>

    <script>
        // Global variables
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let gameStarted = false;
        let gameIsOver = false;
        let selectedPiece = null;
        let turn = 'white';
        let moveCount = 0;
        let history = [];
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let whiteTimer = 300; // 5 minutes in seconds
        let blackTimer = 300;
        let timerInterval;
        
        // Create the 3D scene
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Camera setup
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                Math.PI / 2,
                Math.PI / 3,
                12,
                new BABYLON.Vector3(0, 0, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 8;
            camera.upperRadiusLimit = 20;
            
            // Lighting
            const light = new BABYLON.HemisphericLight(
                "light",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            
            // Create chessboard
            createChessboard(scene);
            
            // Create and position pieces
            await setupPieces(scene);
            
            // Setup interaction
            setupInteraction(scene);
            
            return scene;
        }
        
        function createChessboard(scene) {
            const boardMaterial = new BABYLON.StandardMaterial("boardMat", scene);
            boardMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            
            // Create board squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = BABYLON.MeshBuilder.CreateBox(
                        `square_${row}_${col}`,
                        { height: 0.1, width: 1, depth: 1 },
                        scene
                    );
                    
                    square.position = new BABYLON.Vector3(
                        row - 4 + 0.5,
                        -0.05,
                        col - 4 + 0.5
                    );
                    
                    const material = new BABYLON.StandardMaterial(
                        `squareMat_${row}_${col}`,
                        scene
                    );
                    material.diffuseColor = (row + col) % 2 === 0
                        ? new BABYLON.Color3(1, 1, 1)
                        : new BABYLON.Color3(0.4, 0.4, 0.4);
                    
                    square.material = material;
                    square.boardPosition = { row, col };
                }
            }
        }

        // Piece models - using basic shapes for now
        async function loadPieceModel(scene, type) {
            const modelMap = {
                'pawn': 'pawn.glb',
                'rook': 'rook.glb',
                'knight': 'knight.glb',
                'bishop': 'bishop.glb',
                'queen': 'queen.glb',
                'king': 'chess_king.glb'
            };

            const fileName = modelMap[type.toLowerCase()];
            if (!fileName) {
                throw new Error(`Unknown piece type: ${type}`);
            }

            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    "",
                    "./",  // Assuming models are in the same directory
                    fileName,
                    scene
                );

                // Get the root mesh of the imported model
                const rootMesh = result.meshes[0];
                
                // Create a container mesh to hold the model
                const container = new BABYLON.Mesh("container", scene);
                
                // Parent all imported meshes to the container
                result.meshes.forEach(mesh => {
                    if (mesh !== rootMesh) {
                        mesh.parent = container;
                    }
                });

                // Adjust scale if needed (modify these values based on your models)
                container.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);

                // Center the model
                const boundingBox = container.getHierarchyBoundingVectors(true);
                const dimensions = boundingBox.max.subtract(boundingBox.min);
                const centerOffset = dimensions.scale(0.5);
                container.position.y = -boundingBox.min.y;

                return container;
            } catch (error) {
                console.error(`Error loading model ${fileName}:`, error);
                throw error;
            }
        }

        async function createPiece(scene, type, row, col, color) {
            const piece = await loadPieceModel(scene, type);
            
            // Position the piece on the board
            piece.position = new BABYLON.Vector3(
                row - 4 + 0.5,
                0,  // The model should be centered on its base
                col - 4 + 0.5
            );
            
            // Apply color material to all meshes in the hierarchy
            const material = new BABYLON.StandardMaterial(`${color}${type}Mat`, scene);
            material.diffuseColor = color === 'white'
                ? new BABYLON.Color3(0.9, 0.9, 0.9)
                : new BABYLON.Color3(0.2, 0.2, 0.2);
            
            piece.getChildMeshes().forEach(mesh => {
                mesh.material = material;
            });
            
            piece.pieceInfo = { type, color };
            boardState[row][col] = piece;
            
            return piece;
        }

        function updatePieceScales(scale) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        // Apply scale while maintaining the original model scale
                        const baseScale = 0.5; // matches the initial scale set in loadPieceModel
                        piece.scaling = new BABYLON.Vector3(
                            baseScale * scale,
                            baseScale * scale,
                            baseScale * scale
                        );
                    }
                }
            }
        }

        function updateTimerDisplay() {
            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };
            
            document.getElementById('white-timer').textContent = `White: ${formatTime(whiteTimer)}`;
            document.getElementById('black-timer').textContent = `Black: ${formatTime(blackTimer)}`;
        }

        function endGame(winner) {
            gameIsOver = true;
            clearInterval(timerInterval);
            history.push(`Game Over - ${winner} wins!`);
            document.getElementById('history').innerHTML = history.join('<br>');
            alert(`Game Over - ${winner} wins!`);
        }

        // Initialize the scene and game
        let scene;
        createScene().then(newScene => {
            scene = newScene;
            engine.runRenderLoop(() => {
                scene.render();
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            engine.resize();
        });

        // Event listeners
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('exportButton').addEventListener('click', () => {
            BABYLON.GLTF2Export.GLBAsync(scene, "chess_game").then((glb) => {
                glb.downloadFiles();
            });
        });

        const scaleSlider = document.getElementById('pieceScale');
        const scaleValue = document.getElementById('scaleValue');
        
        if (scaleSlider && scaleValue) {
            scaleSlider.addEventListener('input', (event) => {
                const newScale = parseFloat(event.target.value);
                scaleValue.textContent = newScale.toFixed(1);
                updatePieceScales(newScale);
            });
        }
    </script>
</body>
</html>
